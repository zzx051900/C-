- 网课视频
  - 青岛大学王卓：10，11，12，13，14，&15，&16，17，18，19，20，21，22

# 2.线性表

## 案例：稀疏多项式的运算

- 创建一个新数组c
- 分别从头遍历比较a和b的每一项
  - 指数相同：对应系数相加，若其和不为零，则在c中增加一个新项
  - 指数不相同：则将较小项复制到c中
- 当其中一个多项式遍历完毕，将另一个剩余项复制到c中即可

## 线性表的基本操作：

1. InitList(&L)

   - 操作结果：构建一个空的线性表L

2. DestroyList(&L)

   - 初始条件：线性表L已经存在
   - 操作结果：销毁线性表L（表本身消失）

3. ClearList(&L)

   - 初始条件：线性表L已经存在
   - 操作结果：将线性表L重置为空表（表仍存在）

4. ListEmpty(L)

   - 初始条件：线性表L已经存在
   - 操作结果：若线性表为空，则返回TURE；否则返回FALSE

5. ListLength(L)

   - 初始条件：线性表L已经存在
   - 操作结果：返回线性表中元素个数

6. GetElem(L,i,&e)

   - 初始条件：线性表L已经存在，1<=i<=ListLength(L)
   - 操作结果：用e返回线性表L中第i个元素的值

7. LocateElem(L,e,compare())

   - 初始条件：线性表L已经存在，compare()是数据元素判定函数
   - 操作结果：返回L中第一个与e满足compare()的数据元素的位序，若不存在，则返回0

8. PriorElem(L,cur_e,&pre_e)

   - 初始条件：线性表L已经存在
   - 操作结果：若cur_e，是L的数据元素，且不是第一个，则用pre_e返回他的前驱，否则操作失败，pre_e无意义

9. NextElem(L,cur_e,&next_e)

   - 初始条件：线性表L已经存在

   - 操作结果：若cur_e，是L的数据元素，且不是最后一个，则用next_e返回他的前驱，否则操作失败，next_e无意义

10. ListInsert(&L,i,e)

    - 初始条件：线性表L已经存在，i<=i<=ListLength(L)+1
    - 操作结果：在L的第i个位置前插入新的元素e，L的长度加一

11. ListDelete(&L,i,&e)

    - 初始条件：线性表L已经存在，i<=i<=ListLength(L)
    - 操作结果：删除L的第i个数据元素，并用e返回其值，L的长度减一

12. ListTraverse(&L,visited())

    - 初始条件：线性表L已经存在
    - 操作结果：依次对线性表L中每个元素调用visited()

## 顺序表

- 顺序表中元素存储位置的计算
  - 假设线性表的每个元素需占用i个存储单元，则第i+j个元素的存储位置和第i个元素的存储位置之间满足关系：
    - LOC(a(n+1))=LOC(a(n))+i

- 顺序表的特点

  - 以物理位置相邻表示逻辑关系，任一元素均可随机存取

- 顺序表

  1. 地址连续
  2. 依次存放
  3. 随机存取
  4. 类型相同

- 顺序表的类C语言代码实现

  - ```c
    #define LIST_INIT_SIZE 100//线性表存储空间的初始分配量
    typedef struct
    {
        ElemType elem[LIST_INIT_SIZE];//方案1：静态数组方式
        ElemType *elem;//方案2：动态内存分配方式
        int length;//当前长度
    }SqList;
    SqList L;//定义变量L，L是SqList这种类型的变量，L是个顺序表
    L.elem=(ElemType*)malloc(sizeof(ElemType)*MAXSIZE);//动态内存分配
    ```

- 多项式的顺序存储结构类型定义

  - ```c
    #define MAXSIZE 1000  //多项式可能达到的最大长度
    typedef struct  //多项式非零项的定义
    {
        float p;//系数
        int e;//指数
    }Polynomial;//多项式
    typedef struct
    {
        Polynomial *elem;//存储空间的首地址，以自定义数据类型建立的数组
        int length;//多项式中当前项的个数
    }SqList;//多项式的顺序存储结构类型为SqList
    ```

- 图书表的顺序存储结构类型定义

  - ```c
    #define MAXSIZE 10000  //图书表可能达到的最大长度
    typedef stcuct  //单本图书信息定义
    {
        char no[20]; //图书ISBN
        char name[50]; //图书名字
        float price; //图书价格
    }Book;
    typedef struct
    {
        Book *elem; //存储空间的基地址
        int length; //图书表中的当前图书个数
    }SqList; //图书表的顺序存储结构为SqList
    ```

- 操作算法中用到的预定常量和类型

  - ```c
    //函数结果状态代码
    #define TURE 1
    #define FALSE 0
    #define OK 1
    #define ERROR 0
    #define INFEASIBLE -1
    #define OVERFLOW -2
    //Status 是函数的类型，其值的函数结果代码
    typedef int Status
    typedef char ElemType    
    ```

- 顺序表基本操作的实现（类C语言代码）

  - 算法1：线性表L的初始化（参数用引用）

    - ```c
      Status InitList_Sq(SqList &L)		//构造一个空的顺序表L
      {
          L.elem=new ElemType[MAXSIZE];	//为顺序表分配空间，C++类型？？
          if(!L.elem)
              exit(OverFLOW);				//存储分配失败,异常处理
          L.length=0;						//空表长度为0
          return 0;
      }
      ```

  - 算法2：销毁线性表L

    - ```c
      void DestroyList(SqList &L)
      {
          if(L.elem)
              delete L.elem;  //释放空间，C++语法，具体C语言代码实现不是这样
      }
      ```

  - 算法3：清空线性表L

    - ```c
      void ClearList(SqList &L)
      {
          L.length=0;  //将线性表长度置为0
      }
      ```

  - 算法4：求线性表长度

    - ```c
      int GetLength(SqList L)
      {
          return (L.length);
      }
      ```

  - 算法5：判断线性表L是否为空

    - ```c
      int IsEmpty(SqList L)
      {
          if(L.length==0)
              return 1;  //若为空，则返回1
          return 0;
      }
      ```
    
  - 算法6：顺序表取值（根须位置i获取相应位置数据元素的值，用e返回）
  
    - ```c
      int GetElem(SqList L,int i,ElemType &e)
      {
          if(i<1||i>L.length)
              return ERROR;  //判断i值是否合理，若不合理，返回ERROR
          e=L.elem[i-1];  //第i-1个单元存储着第i个数据
          return OK;
      }
      //随机存取，时间复杂度为O(1)
      ```
  
  - 算法7：顺序表的查找
  
    - ```c
      //在线性表L中查找与指定值e相同的数据元素的位置
      //从表的一端开始，逐个进行记录的关键字和给定值的比较。找到，返回该元素的位置序号，未找到，则返回0
      int LocateElem(SqList L,ElemType e)
      {
          for(i=0;i<L.length;i++)
          {
              if(L.length[i]==e)
                  return i+1;//eg:数组a[0]的位置序号是1
          }
          return 0;//未找到，返回0
      }
      ```
  
  - 算法8：顺序表的插入
  
    - ```c
      /*算法思想：
      1.判断插入位置i是否合法(i<1||i>L.length+1)
      2.判断顺序表的存储空间是否已满，若已满则返回ERROR
      3.将第n至第i位的元素依次向后移动一个位置，空出第i个位置
      4.将要插入的新元素放入第i个位置
      */
      Status ListInsert_Sq(SqList &L,int i,ElemType e)
      {
          if(i<1||i>L.length+1)
              return ERROR;   //i值不合法
          if(L.length==MAXSIZE)
              return ERROR;   //当前存储空间已满
          for(j=L.length-1;j>=i-1;j++)
              L.elem[j+1]=L.elem[j];    //插入位置及之后元素后移
          L.elem[i-1]=e;  //将新元素e放入第i个位置
          L.length++;     //表长加一
          return OK;
      }
      ```
  
  - 算法9：顺序表的删除
  
    - ```c
      /*算法思想：
      1.判断删除位置是否合法(1<i<n)
      2.将第i+1至n位的元素依次向前移动一个位置
      3.表长减一，返回OK
      */
      Status ListDelete_Sq(SqList &L,int i)
      {
          if(i<1||i>L.length)
              return ERROR;   //i值不合法
         for(j=i;j<L.length-1;j++)
              L.elem[j-1]=L.elem[j];   //元素前移
          L.length--; 
      }
      ```
  
## 链表
  
  - 在链表中设置头结点有什么好处？
    1. 便于首元结点的处理
       - 首元结点的地址保存在头结点的指针域中，所以在链表第一个位置上的操作和其他位置一致，无需进行特殊处理
    2. 便于空表和非空表的统一处理
       - 无论链表是否为空，头指针都是指向头结点的非空指针，因此空表和非空表的处理也就统一了
  - 