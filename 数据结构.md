- 网课视频
  - 青岛大学王卓（共173）：10，11，12，13，14，**15**，**16**，17，18，19，20，21，22，23，24，25，26，27，28，29，30，31，32，33，34，35，36，37，38，39，40，41，42，43，44，45，46，47，48，49，50，51，52，53，54，55，56，57，**58**，59，60，61，62，63，64，65，66，**67**(有大问题，看天勤讲解的KMP算法及代码实现），68，69，70，71，72，73，74，75，76，78，79，80，81，82，83，84，85，86，87，88，89，90，91，92，93，94，95，96，97，98，99，100，101，102，103，104，105，106，107，...，137，138，139，140，**141**
- 注意：类C语言使用引用传参(&)，是借用C++语法中的内容，C语言实现时使用指针(*）传参，与类C代码有很大不同
- 数字编号分级：
  - 第一层为汉字数字加顿号，例如：一、二、三、；
  - 第二层为括号中包含汉字数字，例如：（一）、（二）、（三）； 
  - 第三层为阿拉伯数字加下脚点，例如：1.、2.、3.；
  - 第四层为括号中包含阿拉伯数字，例如：（1）、（2）、（3）； 
  - 第五层为小写英文字母，例如：a、b、c；


[TOC]



# 基本结构

- 数据结构的基本概念
  - 第一章 绪论

- 基本数据结构

  - 线性结构

    - 第二章 线性表

    - 第三章 栈和队列

    - 第四章 串、数组和广义表

  - 非线性结构
    - 第五章 树
    - 第六章 图

- 基本数据处理技术

  - 第七章 查找
  - 第八章 排序

# 一.绪论

- 程序 = 数据结构 + 算法
- 基本结构：
  - 数据结构的基本概念（绪论）
  - 基本数据结构
    - 线性结构
      - 线性表
      - 栈和队列
      - 串
      - 数组和广义表

    - 非线性结构
      - 树
      - 图

  - 基本数据处理技术
    - 查找
    - 排序


## （一）数据结构的研究内容

- 数据结构是一门研究非数值计算的程序设计种计算机的操作对象以及它们之间关系和操作的学科

## （二）基本概念和术语

## （三）抽象数据类型的表示和实现

## （四）算法和算法分析

# 二.线性表

## （一）线性表的定义和特点

- 线性表是具有相同特性的数据元素的一个有限序列，由n（n>=0）个数据元素（结点）a1、a2、a3...组成的有限序列
  - 其中数据元素的个数n定义为表的长度
  - 当n=0时称为空表
  - 将非空的线性表（n>0）记作：（a1，a2，...，an）
  - 这里的数据元素ai只是一个抽象的符号，其具体含义在不同情况下可以不同

- 案例：稀疏多项式的运算

  - 创建一个新数组c
    - 分别从头遍历比较a和b的每一项
      - 指数相同：对应系数相加，若其和不为零，则在c中增加一个新项
      - 指数不相同：则将较小项复制到c中


  - 当其中一个多项式遍历完毕，将另一个剩余项复制到c中即可


## （二）线性表的基本操作：

1. `InitList(&L)`

   - 线性表的初始化
   - 操作结果：构建一个空的线性表L

2. `DestroyList(&L)`

   - 销毁线性表

   - 初始条件：线性表L已经存在
   - 操作结果：销毁线性表L（表本身消失）

3. `ClearList(&L)`

   - 清空线性表
   - 初始条件：线性表L已经存在
   - 操作结果：将线性表L重置为空表（表仍存在）

4. `ListEmpty(L)`

   - 线性表判空
   - 初始条件：线性表L已经存在
   - 操作结果：若线性表为空，则返回TURE；否则返回FALSE

5. `ListLength(L)`

   - 求线性表长
   - 初始条件：线性表L已经存在
   - 操作结果：返回线性表中元素个数

6. `GetElem(L,i,&e)`

   - 线性表取值
   - 初始条件：线性表L已经存在，1<=i<=ListLength(L)
   - 操作结果：用e返回线性表L中第i个元素的值

7. `LocateElem(L,e,compare())`

   - 初始条件：线性表L已经存在，compare()是数据元素判定函数
   - 操作结果：返回L中第一个与e满足compare()的数据元素的位序，若不存在，则返回0

8. `PriorElem(L,cur_e,&pre_e)`

   - 初始条件：线性表L已经存在
   - 操作结果：若cur_e，是L的数据元素，且不是第一个，则用pre_e返回他的前驱，否则操作失败，pre_e无意义

9. `NextElem(L,cur_e,&next_e)`

   - 初始条件：线性表L已经存在

   - 操作结果：若cur_e，是L的数据元素，且不是最后一个，则用next_e返回他的前驱，否则操作失败，next_e无意义

10. `ListInsert(&L,i,e)`

    - 线性表的插入
    - 初始条件：线性表L已经存在，i<=i<=ListLength(L)+1
    - 操作结果：在L的第i个位置前插入新的元素e，L的长度加一

11. `ListDelete(&L,i,&e)`

    - 线性表的删除
    - 初始条件：线性表L已经存在，i<=i<=ListLength(L)
    - 操作结果：删除L的第i个数据元素，并用e返回其值，L的长度减一

12. `ListTraverse(&L,visited())`

    - 遍历线性表
    - 初始条件：线性表L已经存在
    - 操作结果：依次对线性表L中每个元素调用visited()

## （三）算法中用到的预定义常量和类型

- ```c
  //函数结果状态代码
  #define TURE 1
  #define FALSE 0
  #define OK 1
  #define ERROR 0
  #define INFEASIBLE -1
  #define OVERFLOW -2
  //Status 是函数的类型，其值是函数结果状态代码
  typedef int Status;
  typedef char ElemType;
  ```

## （四）顺序表

### 1.顺序表中元素存储位置的计算

- 假设线性表的每个元素需占用i个存储单元，则第i+j个元素的存储位置和第i个元素的存储位置之间满足关系：
  - LOC(a(n+1))=LOC(a(n))+i

### 2.顺序表的特点

- 以物理位置相邻表示逻辑关系，任一元素均可随机存取

### 3.顺序表

1. 地址连续
2. 依次存放
3. 随机存取
4. 类型相同

### 4.顺序表的代码实现

- 结构定义：

  - 类C语言代码：
  
    - ```c
      #define LIST_INIT_SIZE 100//线性表存储空间的初始分配量
      typedef struct
      {
          ElemType elem[LIST_INIT_SIZE];//方案1：静态数组方式
          ElemType *elem;//方案2：动态内存分配方式
          int length;//当前长度
      }SqList;
      SqList L;//定义变量L，L是SqList这种类型的变量，L是个顺序表
      L.elem=(ElemType*)malloc(sizeof(ElemType)*MAXSIZE);//动态内存分配
      ```
  
  - C语言代码实现：
  
    - ```c++
      //顺序表数据结构
      typedef struct
      {
      	ElemType *elem;
      	int length;
      }SqList;
      SqList L;
      L->elem = (ElemType*)malloc(MAXSIZE*sizeof(ElemType));	//动态分配内存，创建头结点
      ```
  


- 多项式的顺序存储结构类型定义

  - ```c
    #define MAXSIZE 1000  //多项式可能达到的最大长度
    typedef struct  //多项式非零项的定义
    {
        float p;//系数
        int e;//指数
    }Polynomial;//多项式
    typedef struct
    {
        Polynomial *elem;//存储空间的首地址，以自定义数据类型建立的数组
        int length;//多项式中当前项的个数
    }SqList;//多项式的顺序存储结构类型为SqList
    ```

- 图书表的顺序存储结构类型定义

  - ```c
    #define MAXSIZE 10000  //图书表可能达到的最大长度
    typedef stcuct  //单本图书信息定义
    {
        char no[20]; //图书ISBN
        char name[50]; //图书名字
        float price; //图书价格
    }Book;
    typedef struct
    {
        Book *elem; //存储空间的基地址
        int length; //图书表中的当前图书个数
    }SqList; //图书表的顺序存储结构为SqList 
    ```

### 5.顺序表基本操作的实现（代码）

  #### 算法1：线性表L的初始化（参数用引用）

- 类C代码：

  - ```c
    Status InitList_Sq(SqList &L)		//构造一个空的顺序表L
    {
      L.elem=new ElemType[MAXSIZE];	//为顺序表分配空间，C++类型？？
      if(!L.elem)
          exit(OverFLOW);				//存储分配失败,异常处理
      L.length=0;						//空表长度为0
      return 0;
    }
    ```

- C语言实现：

  - ```c++
    Status InitList_Sq(SqList *L)
    {
    	L->elem = (ElemType*)malloc(MAXSIZE*sizeof(ElemType));	//动态分配内存，创建头结点
    	if (!L->elem)	//异常处理，检查存储空间是否分配成功
    		return ERROR;
    	L->length = 0;	//表中元素为0
    	return OK;
    }
    ```

#### 算法2：销毁线性表L    

- 类C代码：

  - ```c
    void DestroyList(SqList &L)
    {
        if(L.elem)
            delete L.elem;  //释放空间，C++语法，具体C语言代码实现不是这样
    }
    ```

- C语言实现：

  - ```c
    void DestroyList_Sq(SqList* L)
    {
    	if (L->elem)
    		free(L->elem);
    	L = NULL;
    }
    ```

#### 算法3：清空线性表L

- 类C代码：

  - ```c
    void ClearList(SqList &L)
    {
        L.length=0;  //将线性表长度置为0
    }
    ```

- C语言实现：

  - ```c
    void ClearList(SqList* L)
    {
    	L->length = 0;
    }
    ```

#### 算法4：求线性表长度

- 类C代码：

  - ```c
      int GetLength(SqList L)
      {
          return (L.length);
      }
    ```

- C语言实现：

  - ```c
    int GetLength(const SqList* L)
    {
    	return L->length;
    }
    ```

#### 算法5：判断线性表L是否为空

- ```c
   int IsEmpty(SqList L)
    {
        if(L.length==0)
            return 1;  //若为空，则返回1
        return 0;
    }
  ```

#### 算法6：顺序表取值（根须位置i获取相应位置数据元素的值，用e返回）

- 类C代码：

  - ```c
     Status GetElem(SqList L,int i,ElemType &e)
      {
          if(i<1||i>L.length)
              return ERROR;  //判断i值是否合理，若不合理，返回ERROR
          e=L.elem[i-1];  //第i-1个单元存储着第i个数据
          return OK;
      }
      //随机存取，时间复杂度为O(1)
    ```

- C语言实现：

  - ```c
    Status GetElem_Sq(SqList L, int i, ElemType *e)
    {
    	if (L.length==0 || i<1 || i>L.length)
    		return ERROR;  //判断i值是否合理，若不合理，返回ERROR
    	*e = L.elem[i - 1];  //第i-1个单元存储着第i个数据
    	return OK;
    }
    ```

#### 算法7：顺序表的查找

- ```c
    //在线性表L中查找与指定值e相同的数据元素的位置
    //从表的一端开始，逐个进行记录的关键字和给定值的比较。找到，返回该元素的位置序号，未找到，则返回0
    int LocateElem(SqList L,ElemType e)
    {
        for(i=0;i<L.length;i++)
        {
            if(L.length[i]==e)
                return i+1;//eg:数组a[0]的位置序号是1
        }
        return 0;//未找到，返回0
    }
  ```

#### 算法8：顺序表的插入

- 类C代码：

  - ```c
     /*算法思想：
      1.判断插入位置i是否合法(i<1||i>L.length+1)
      2.判断顺序表的存储空间是否已满，若已满则返回ERROR
      3.将第n至第i位的元素依次向后移动一个位置，空出第i个位置
      4.将要插入的新元素放入第i个位置
      */
      Status ListInsert_Sq(SqList &L,int i,ElemType e)
      {
          if(i<1||i>L.length+1)
              return ERROR;   //i值不合法
          if(L.length==MAXSIZE)
              return ERROR;   //当前存储空间已满
          for(j=L.length-1;j>=i-1;j++)
              L.elem[j+1]=L.elem[j];    //插入位置及之后元素后移
          L.elem[i-1]=e;  //将新元素e放入第i个位置
          L.length++;     //表长加一
          return OK;
      }
    ```

- C语言实现：

  - ```c
    Status ListInsert_Sq(SqList *L, int i, ElemType e)
    {
    	if (i<1 || i>L->length + 1)	//eg:一共有10个元素(L->length=10)，插入在最后位置的话相当于插入在第11个元素之前，所以i最大只能为L->length+1
    		return ERROR;
    	if (L->length == MAXSIZE)
    		return ERROR;
    	if (i <= L->length)	//若插入位置不在表尾，要移动元素
    	{
    		for (int j = L->length - 1; j >= i - 1; j--)	//表中最后一个元素的下标为L->length-1
    		{
    			L->elem[j + 1] = L->elem[j];
    		}
    	}
    	L->elem[i - 1] = e;	//将新元素插入
    	L->length++;	//表长加一
    	return OK;
    }
    ```

#### 算法9：顺序表的删除

- 类C代码：

  - ```c
      /*算法思想：
      1.判断删除位置是否合法(1<i<n)
      2.将第i+1至n位的元素依次向前移动一个位置
      3.表长减一，返回OK
      */
      Status ListDelete_Sq(SqList &L,int i)
      {
          if(i<1||i>L.length)
              return ERROR;   //i值不合法
         for(j=i;j<L.length-1;j++)
              L.elem[j-1]=L.elem[j];   //元素前移
          L.length--; 
      }
    ```

- C语言实现：

  - ```c
    Status ListDelete_Sq(SqList *L, int i, ElemType *e)
    {
    	if (L->length == 0)
    		return ERROR;
    	if (i<1 || i>L->length)
    		return ERROR;
    	*e = L->elem[i - 1];
    	if (i < L->length - 1)	//如果删除位置不在最后，需要移动元素；如果在最后，则只需要表长减一
    	{
    		for (int j = i - 1; j <= L->length - 2; j++)
    		{
    			L->elem[j] = L->elem[j + 1];
    		}
    	}
    	L->length--;	//表长减一
    	return OK;
    }
    ```

## （五）链表

### 1.在链表中设置头结点有什么好处？

1. 便于首元结点的处理
   - 首元结点的地址保存在头结点的指针域中，所以在链表第一个位置上的操作和其他位置一致，无需进行特殊处理
2. 便于空表和非空表的统一处理
   - 无论链表是否为空，头指针都是指向头结点的非空指针，因此空表和非空表的处理也就统一了

### 2.单链表结点的定义：

- ```c
  typedef struct Lnode
  {
      ElemType data; //结点的数据域
      struct Lnode *next; //结点的指针域
  }Lnode,*LinkList; //LinkList为指向结构体Lnode的指针类型
  //定义一个结构体类型指针的两种方式
  Lnode *p;
  LinkList L;
  //一般区分使用:
  //定义链表L
  LinkList L;
  //定义结点指针p:
  Lnode *p;
  ```

### 3.单链表结构的定义和表示

- eg：存储学生学号、姓名、成绩的单链表结点类型定义

  - 方式a：不常用，因为存在多个数据域

    - ```c
      typedef struct student
      {
          char num[8];//学号
          char name[8];//姓名
          int score;//成绩
          struct student *next; //指针域
      }Lnode,*LinkList;
      
      LinkList L;
      ```
  - 方式b：常用，将多个数据的内容先定义成一个结构体

    - ```c
      typedef struct
      {
          char num[8];//学号
          char name[8];//姓名
          int score;//成绩
      }ElemType;
      
      typedef struct Lnode
      {
          ElemType data;
          struct Lnode *next;
      }Lnode,*LinkList;
      ```

### 4.单链表基本操作的类C语言实现

#### 算法1：单链表的初始化

- 类C代码：

  - ```c
    /*算法步骤：
    1.生成新节点作为头结点，用头指针L指向头结点
    2.将头结点的指针域置空
    */
    Status InitList_L(LinkList &L)
    {
        L=(LinkList)malloc(sizeof(Lnode));
        L->next=NULL;
        return OK;
    }
    ```

- C语言实现：

  - ```c
    Status InitList(LinkList *L)   //等价于Node **L  
    {   
        *L=(LinkList)malloc(sizeof(Node)); /* 产生头结点,并使L指向此头结点 */  
        if(!(*L)) /* 存储分配失败 */  
                return ERROR;  
        (*L)->next=NULL; /* 指针域为空 */  
      
        return OK;  
    } 
    ```

  - 使用二级指针，因为要修改头指针的指向，若参数传递的是头指针而不是头指针的地址，则在函数调用后头指针的内容即头指针的指向仍然是最开始的那个垃圾值，并没有指向我们为其动态分配的空间。（**二级指针的理解**）

#### 算法2：判断链表是否为空

- 类C代码

    - ```c
      //空表：链表中无元素，但头指针和头结点仍存在
      //算法思路：判断头结点指针域是否为空
      int ListEmpty(LinkList L) //若为空返回1，否则返回0
      {
          if(L->next)
              return 0;
          else
              return 1;
      }
      ```

- C语言实现

    - ```c
        int IsEmptyLinkList(const LinkList* L)//常量指针，不可以通过*L改变L
        {
        	if ((*L)->next == NULL)
        		return 1;
        	else
        		return 0;
        }
        ```

    - ```c
        int Empty(LinkList L)
        {
        
        	if (L->next == NULL)
        		return 1;
        	return 0;
        }
        ```

#### 算法3：单链表的销毁，销毁后不存在

- 类C代码：

    - ```c
      //算法思路：从头指针开始，依次释放所有结点
      Status DestroyList_L(LinkList &L)
      {
          Lnode *p;
          while(L)
          {
              p=L;
              L=L->next;
              free(p);
          }
          return OK;
      }
      ```

- C语言实现：

  - ```c
    Status DestoryList_L(LinkList *L)
    {
    	LNode* p = *L;	//p此时指向头结点
    	//注意此时不能直接释放p，因为头结点中还存放着下一结点的地址，释放就找不到下一个结点了
    	while (*L)
    	{
    		*L = (*L)->next;
    		free(p); //第一次释放即释放掉头结点
    		p = *L;
    	}
    	return OK;
    }
    ```

#### 算法4：清空单链表

- 类C代码：

    - ```c
      //依次释放所有结点，并将头结点指针域设置为空
      Status ClearList_L(LinkList &L)
      {
          Lnode *p,*q;
          p=L->next;
          while(p)
          {
         	 	q=p->next;
          	free(p);
              p=q;
          }
          L->next=NULL;
          return 0;
      }
      ```

- C语言实现：

  - ```c
    Status ClearLinkList(LinkList* L)
    {
    	LNode* p, * q;
    	q = (*L)->next;
    	while (q)
    	{
    		p = q;
    		q = q->next;
    		free(p);
    	}
    	(*L)->next = NULL;
    	return OK;
    }
    ```

  - ```c
    Status ClearList_L(LinkList L)//不需要改变头指针的指向，所以可以不使用二级指针
    {
    	LNode *p, *q;	//p用于指向需要释放的结点，q用于在p释放之前指向下一结点，以使p移动
    	p = L->next;	//p指向首元结点
    	while (p)
    	{
    		q = p->next;   //q指向下一结点
    		free(p);
    		p = q;
    	}
    	L->next = NULL;	//结点释放后还需要将头结点的指针域更改为NULL，形成空表
    	return OK;
    }
    ```

#### 算法5：求单链表表长

- 类C代码：

    - ```c
      //算法思路：从首元结点开始，依次计数所有结点
      int ListLength_L(LinkList L)
      {
          Lnode *p;
          p=L->next;//p指向第一个结点
          i=0;
          while(p)
          {
              i++;
              p->next;
          }
          return i;
      }
      ```

- C语言代码：

  - ```c
    int LenLinkList(const LinkList* L)
    {
    	LNode* p;
    	p = (*L)->next;
    	int i = 0;
    	while (p)
    	{
    		i++;
    		p = p->next;
    	}
    	(*L)->data = i;//将长度存储到L头结点的数据域中
    	return i;
    }
    ```

  - ```c
    int ListLength_L(LinkList L)
    {
    	LNode *p;   //用于指向除头结点以外的结点
    	int count = 0;
    	p = L->next; //指向首元结点
    	while (p)	//当所指结点不为空时，count++，并向后移一位
    	{
    		count++;
    		p = p->next;
    	}
        L->data = count;//将长度存储到L头结点的数据域中
    	return count;
    }
    ```

#### 算法6：取第i个元素的值

  - 按位查找：

    - 类C代码：

      - ```c
        Status GetElem_L(LinkList L,int i,ElemType &e)
        {
            p=L-next;  //p指向首元结点
            j=1;
            while(p&&j<i) //向后扫描直到p指向第i个元素或p为空
            {
                p=p->next;
                ++j;
            }
            if(!p||j>i)
                return ERROR; //第i个元素不存在
            e=p->data;
            return OK;
        }
        ```

    - C语言代码：

      - ```c
        Status LocateElem(const LinkList *L, int i, ElemType *e)
        {
        	LNode* p = (*L)->next;
            int j = 1;
        	while (p && j < i)
        	{
        		j++;
        		p = p->next;
        	}
        	if (!p || j > i)		//如果待查找的元素大于链表长度或者小于1，查找错误
        		return ERROR;
        	*e = p->data;
        	return OK;
        }
        ```

      - ```c
        Status GetElem(LinkList L, int i, ElemType *e)
        {
        	LNode *p = L->next;
        	int j = 1;
        	while (p && j<i) //向后扫描直到p指向第i个元素(j=i-1)或p为空
        	{
        		p = p->next;
        		++j;
        	}
        	if (!p || j>i) //j大于i的情况：如i传入的为0或负数
        		return ERROR;
        	*e = p->data;
        	return OK;
        }
        ```

  - 按值查找：根据指定数据获取该数据所在的位置(地址或序号)

    - 返回地址

      - 类C代码：
    
        - 
          ```c
          Lnode *LocateElem_L(LinkList L,ElemType e)
          {
              p=L->next;
              while(p&&p->data!=e)
              {
                  p=p->next;
              }
              return p;
          }
          ```

      - C语言实现：
    
        - ```c
          LNode* LocateElem_V_LNode(const LinkList *L, ElemType e)
          {
          	LNode* p = (*L)->next;
          	while (p && p->data != e)		//p不为空指针，并且没找到
          	{
          		p = p->next;
          	}
          	return p;			//找到返回结点的地址，没找到返回NULL
          }
          ```
    
        - ```c
          LNode* LocateElem_Ad(LinkList L, ElemType e) //返回值为结构体类型的指针
          {
          	LNode *p = L->next;
          	while (p && p->data != e)	//向后扫描直到p指向元素的数据域为e或p为空（即没找到）
          	{
          		p = p->next;
          	}
          	return p;
          }
          ```
    
    - 返回序号
    
      - 类C代码：
    
        - ```c
          int LocateElem_L(LinkList L,ElemType e)
          {
              p=L->next;
              j=1;
              while(p&&p->data!=e)
              {
                  p=p->next;
                  j++;
              }//如果没找到，则p为空
              if(p)
                  return j;
              return 0;//查找失败返回0
          }
          ```
    
      - C语言实现：
    
        - ```c
          int LocateElem_V_Index(const LinkList *L, ElemType e)
          {
          	LNode* p = (*L)->next;
              int j = 1;
          	while (p && p->data != e)
          	{
          		j++;
          		p = p->next;
          	}
          	if (!p)
          		return 0;		//没找到,返回0
          	else
          		return j;		//找到,返回第几个结点
          }
          ```
    
        - ```c
          int LocateElem_Num(LinkList L, ElemType e)
          {
          	LNode *p = L->next;
          	int j = 1;
          	while (p && p->data != e)
          	{
          		p = p->next;
          		j++;
          	}//如果没找到，则p为空
          	if (p)
          		return j;
          	return 0;//查找失败返回0
          }
          ```

#### 算法7：插入结点（在第i个结点前插入值为e的新结点）

- 类C代码：

    - ```c
      Status ListInsert_L(LinkList &L,int i,ElemType e)
      {
          p=L;
          j=0;
          while(p && j<i-1) //寻找第i-1个结点，p指向i-1结点
          {
              p=p->next;
              j++;
          }
          if(!p||j>i-1)
              return ERROR;  //i大于表长+1或小于1，插入位置非法
          s=(*Lnode)malloc(sizeof(Lnode));    //新建一个s结点（可能有问题）
          s->data=e; //生成新结点，将结点的数据域置为e
          s->next=p->next;
          p->next=s; //顺序不可颠倒
          return OK;
      }
      ```

- C语言实现：

  - ```c
    Status InsertLinkList(LinkList *L, int i, ElemType e)
    {
    	LNode* p = (*L);
    	int j = 0;
    	while (p && j < i - 1)		//找到第i-1个结点
    	{
    		j++;
    		p = p->next;
    	}
    	if (!p || j > i - 1)		//i大于表长+1,或者小于1,插入位置非法
    		return ERROR;
    	LNode* newlnode = (LNode*)malloc(sizeof(LNode));
    	newlnode->data = e;
    	newlnode->next = p->next;
    	p->next = newlnode;
    	return OK;
    }
    ```

#### 算法8：删除第i个结点（删除第i个元素）

- 类C代码：

    - ```c
      Status ListDelete_L(LinkList &L,int i,ElemType &e)
      {
          p=L; //指向头结点
          j=0; 
          while(p->next&&j<i-1) //寻找第i-1个结点，且第i个结点不能为空
          {
              p=p->next;
              j++;
          }
          if(!(p->next)||j>i-1)
              return ERROR;
          q=p->next; //临时保存被删结点的地址以备释放
          p->next=q->next;
          e=q->data; //存放删除结点的数据
          free(q);//释放删除结点的空间
          return OK;
      }
      ```

- C语言代码：

  - ```c
    //将删除值返回
    Status ListDelete_L(LinkList L, int i, ElemType *e)
    {
    	LNode *p = L; //指向头结点
    	LNode *q;
    	int j = 0;
    	while (p->next && j<i - 1) //寻找第i-1个结点，且第i个结点不能为空
    	{
    		p = p->next;
    		j++;
    	}
    	if (!(p->next) || j>i - 1) //要删除结点不存在
    		return ERROR;
    	q = p->next; //临时保存被删结点的地址以备释放
    	p->next = q->next;
    	*e = q->data; //存放删除结点的数据
    	free(q);	//释放删除结点的空间
    	return OK;
    }
    ```

  - ```c
    //不返回删除值
    Status DeleteLinkList(LinkList *L, int i)
    {
    	LNode* p, * q;
    	int j = 1;
    	p = (*L)->next;
    	while (p && j < i - 1)
    	{
    		j++;
    		p = p->next;
    	}
    	if (!p || j > i - 1)
    		return ERROR;
    	q = p->next;
    	p->next = q->next;
    	free(q);
    	return OK;
    }
    ```

#### 算法9：头插法建立单链表

- 类C代码：

    - ```c
      void CreateList_H(LinkList &L,int n) //n 为插入的元素个数
      {
          L=(*Lnode)malloc(sizeof(Lnode)); //头结点
          L->next=NULL;
          for(i=n;i>0;i--)
          {0
              p=(*Lnode)malloc(sizeof(Lnode)); //新结点
              //输入元素，存在p->data;
              p->next=L->next;
              L->next=p;
          }
      } //时间复杂度O(n)
      ```

- C语言实现：

  - ```c
    void CreateLinkList_H(LinkList* L, int n)
    {
    	*L = (LinkList)malloc(sizeof(LNode));
    	(*L)->next = NULL;					//先建立一个头结点
    	int i;
    	for (i = n; i > 0; i--)
    	{
    		LNode* newlnode;
    		newlnode = (LNode*)malloc(sizeof(LNode));
    		printf("Enter the node data:_____\b");
    		scanf("%d", &newlnode->data);
    		newlnode->next = (*L)->next;
    		(*L)->next = newlnode;
    	}
    }
    ```

  - ```c
    Status CreateList_H(LinkList *L, int n)
    {
    	LNode *p, *r;  //p用于指向新结点,r指向头结点
    	//建立一个带有头结点的单链表并将指针域置为空
    	*L = (LinkList)malloc(sizeof(LNode));
    	r = *L;
    	r->next = NULL;
    	//结点添加与赋值
    	for (int i = n; i>0; i--) {
    		p = (LNode *)malloc(sizeof(LNode)); //为新结点动态分配内存
    		p->next = NULL;
    		printf("请输入该链表的第%d个元素：", i);
    		scanf("%d", &p->data);
    		p->next = r->next;
    		r->next = p;
    	}
    	return OK;
    }
    ```

#### 算法10：尾插法建立单链表

- 类C代码：

    - ```c
      /*
      1.从一个空表L开始，将新结点逐个插入到链表尾部，尾指针r指向链表尾部
      2.初始时，r同L均指向头结点。每读入一个数据元素则申请一个新结点，将新结点插入到尾结点后，r指向新结点
      */
      void CreateList_R(LinkList &L,int n)
      {
          L=(*Lnode)malloc(sizeof(Lnode)); //头结点
          L->next=NULL;
          r=L; //尾指针指向头结点
          for(i=0;i<n;i++)
          {
              p=(*Lnode)malloc(sizeof(Lnode)); //新结点
              //输入元素，存在p->data;
              p->next=NULL;
              r->next=p;
              r=p; //尾指针指向新的尾结点
          }
      } //时间复杂度O(n)
      ```

- C语言实现：

  - ```c
    void CreateLinkList_R(LinkList *L, int n)
    {
    	*L = (LinkList)malloc(sizeof(LNode));
    	(*L)->next = NULL;//先建立一个头结点
    	LNode* p;
    	p = *L;
    	int i;
    	for (i = n; i > 0; i--)
    	{
    		LNode* newlnode = (LNode*)malloc(sizeof(LNode));
    		printf("Enter the node data:___\b");
    		scanf("%d", &newlnode->data);
    		newlnode->next = NULL;
    		p->next = newlnode;
    		p = p->next;
    	}
    }
    ```

  - ```c
    Status CreateList_R(LinkList *L, int n)
    {
    	LNode *p, *r;//p用于指向新结点(待插入结点)，r指向尾部结点
    	*L = (LinkList)malloc(sizeof(LNode));
    	r = *L;  //刚开始时r指向头结点
    	r->next = NULL;
    	for (int i = 0; i<n; i++) {
    		p = (LNode *)malloc(sizeof(LNode));   //注意这里不要忘记将这块内存定义为LNode的指针类型
    		printf("请输入该链表的第%d个元素：", i + 1);
    		scanf("%d", &p->data);
    		p->next = NULL;
    		r->next = p;
    		r = r->next;	//尾指针指向新的尾接点
    	}
    	r->next = NULL;//这一步应该不需要
    	return OK;
    }
    ```

#### 算法11：显示单链表

- C语言实现：

  - ```c
    void ShowLinkList(const LinkList* L)
    {
    	LNode* p = (*L)->next;//指向首元结点
    	if (!p)//首元结点为空
    	{
    		puts("The LinkList is empty");
    		return;
    	}
    	int i = 1;
    	while (p)
    	{
    		printf("%d : %d\n", i, p->data);
    		i++;
    		p = p->next;
    	}
    	putchar('\n');
    }
    ```

### 5.循环链表：

- 循环链表：头尾相接的链表（最后一个结点的指针域指向头结点，整个链表形成一个环）
- 优点：从表中任一结点出发均可找到表中其他结点
- 注意：循环链表中没有NULL指针，故涉及遍历操作时，终止条件为是否等于头指针
- eg：带尾指针循环链表的合并（尾指针Ta和Tb）

    - 操作步骤：

        1. p存Ta的表头结点：`p=Ta->next`
        2. Tb表头连接到Ta表尾：`Ta->next=Tb->next->next`
        3. 释放Tb表头结点：`free(Tb-next)`
        4. Tb指向Ta的头结点：`Tb->next=p`

    - ```c
        LinkList Connect(LinkList Ta,LinkList Tb)
        {
            p=Ta->next;
            Ta->next=Tb->next->next;
            free(Tb-next);
            Tb->next=p;
            return Tb;
        }
        ```

### 6.双向链表：

- 在单链表的每个结点里再增加一个指向其直接前驱的指针域prior

- 双向链表的结构定义：

    - ```c
        typedef struct DuLnode
        {
            ElemType data;
            struct DuLnode *prior,*next;
        }DuLnode,*DuLinkList;
        ```

- 双向链表的对称性：

    - `p->prior->next=p=p->next->prior`

- 双向链表中，插入、删除操作需要同时修改两个方向上的指针

    - 双向链表的插入操作：

        - ```c
            void ListInsert_DuL(DuLinkList &L;int i;ElemType e) //在带头结点的双向链表L的第i个位置前插入元素e
            {
                if(!(p=GetElemP_DuL(L,i))) //找到第i个元素
                    return ERROR;
                s=(*DuLnode)malloc(sizeof(DuLnode));
                s->data=e;
                s->prior=p->prior; //将新结点的前驱改为p的前驱
                p->prior->next=s; //将p的前驱的后继改为新结点
                p->prior=s; //p的前驱改为新结点s
                s->next=p; //新结点s的后继改为p
            }
            ```

    - 双向链表的删除：

        - ```c
            void ListDelete_DuL(DuLinkList &L;int i;ElemType &e) //删除第i个元素，并用e返回
            {
                if(!(p=GetElemP_DuL(L,i))) //找到第i个元素
                    return ERROR;
                e=p->data;
                p->prior->next=p->next; //p的前驱的后继改为p的后继
                p->next->prior=p->prior; //p的后继的前驱改为p的前驱
                free(p);
            }
            ```

### 7.单链表、循环链表和双向链表的时间效率比较

- |                                 |         查找首元结点         |             查找表尾结点              |            查找结点*p的前驱结点            |
    | ------------------------------- | :--------------------------: | :-----------------------------------: | :----------------------------------------: |
    | 带头结点的单链表L               |    L->next 时间复杂度O(1)    | 从L->next依次向后遍历，时间复杂度O(n) |          通过p->next无法找到前驱           |
    | 带头结点仅设头指针L的循环单链表 |    L->next 时间复杂度O(1)    | 从L->next依次向后遍历，时间复杂度O(n) |  通过p->next可以找到前驱，时间复杂度O(n)   |
    | 带头结点仅设尾指针R的循环单链表 | R->next->next 时间复杂度O(1) |           R，时间复杂度O(1)           |  通过p->next可以找到前驱，时间复杂度O(n)   |
    | 带头指针的双向循环链表L         |    L->next 时间复杂度O(1)    |       L->prior，时间复杂度O(1)        | p->prior，时间复杂度O(1)顺序表和链表的比较 |

### 8.常见问题：

1. 为什么单链表初始化时用二级指针，而插入操作时用一级指针？

   - 在初始化过程中，需要修改头指针，因此要用到二级指针传递头指针的地址，这样才能修改头指针。这与普通变量类似，当需要修改普通变量的值，需传递其地址。使用二级指针，很方便就修改了传入的结点一级指针的值。 如果用一级指针，则只能通过指针修改指针所指内容，却无法修改指针的值，也就是指针所指的内存块。

   - 在使用带头结点的单链表时
     1、初始化链表头部指针需要用二级指针
     2、销毁链表需要用到二级指针
     3、插入、删除、遍历、清空结点用一级指针即可

     注意：
     如果是不带头结点的单链表，插入、删除和清空结点也需要二级指针（比如往空链表中插入一个节点时，新插入的节点就是链表的头指针，此时会改动头指针。同理，删除第一个结点和清空结点都会改动头指针）。

## （六）顺序表的链表的比较

- 链式存储结构：
  - 优点：
    - 节点空间可以动态申请和释放
    - 数据元素的逻辑次序靠结点的指针来指示，插入和删除时不需要移动数据元素
  - 缺点：
    - 存储密度小，每个结点的指针域需额外占用存储空间。当每个结点的数据域所占字节不多时，指针域所占存储空间的比重显得很大（存储密度=结点数据所占空间/结点所占的空间总量）
    - 链式存储结构时非随机存取结构》对任意结点的操作都要从头指针依指针链查找到该结点
- 空间：
  - 存储空间：
    - 顺序表：预先分配，会导致空闲限制或溢出
    - 链表：动态分配，不会出现存储空间闲置或溢出
  - 存储密度：
    - 顺序表：不用为表示结点间的逻辑关系而额外增加存储开销，存储密度为1
    - 链表：需要借助指针来体现元素间的逻辑关系，存储密度小于1
- 时间：
  - 存取元素：
    - 顺序表：随机存取，按位置访问元素时间复杂度为O(1)
    - 链表：顺序存取，按位置访问元素时间复杂度为O(n)
  - 插入、删除：
    - 顺序表：平均移动表中一半元素，时间复杂度为O(n)
    - 链表：不需要移动元素，确定位置后，时间复杂度为O(1)
- 使用情况：
  - 顺序表：
    1. 表长变化不大，且能事先确定变化的范围
    2. 很少进行插入或删除的操作，经常按元素位置序号访问数据元素
  - 链表：
    1. 长度变化很大
    2. 频繁进行插入或删除操作 

## （七）线性表的应用

### 1.线性表的合并

- 算法步骤：

  - 依次取出Lb中的每个元素，执行以下操作：
    1. 在La中查找该元素
    2. 如果找不到，则将其插入到La的最后

- ```c
  void union(List &La,List Lb)//仅表示思路
  {
      La_len=ListLength(La);//求线性表La的长度
      Lb_len=ListLength(Lb);
      for(i=1;i<Lb_len;i++)//遍历Lb中元素
      {
          GetElem(Lb,i,e);
          if(!(LocateElem(La,e)))//执行条件为，在La中找不到元素e
              ListInsert(La,++La_len,e);//插入到第表长加一个位置
      }
  }
  ```

### 2.有序表的合并（顺序表）

- 已知线性表La和Lb中的数据元素非递减有序排列，现要求将两表归并为一个新的非递减有序排列
- 算法步骤：
  1. 创建一个空表c
  2. 依次从La和Lb中摘取元素值较小的结点插入到Lc表的最后，直至其中一个表为空
  3. 继续将没有空的那个表的剩余结点插入到Lc表的最后
  
- ```c
  void MergeList_Sq(SqList LA,SqList LB,SqList &LC)
  {
      pa=LA.elem;
      pb=LA.elem;//指针pa、pb分别指向两个表的第一个元素
      LC.length=LA.length+LB.length;
      LC.elem=(*ElemType)malloc(LC.length*sizeof(Elemtype));
      pc=LC.elem;//
      pa_last=LA.elem+LA.length-1;//指向LA表最后一个元素，用来记录是否遍历到了表尾
      pb_last=LB.elem+LB.length-1;
      while(pa<=pa_last&&pb<=pb_last)//两表都不为空时
      {
          if(*pa<=*pb)
          {
              *pc=*pa;
              pc++;//指针右移
              pa++;
              //或直接写成：*pc++=*pa++;
          }
          else
          {
              *pc=*pb;
              pc++;//指针右移
              pb++;
              //或直接写成：*pc++=*pb++;
          }
          while(pa<=pa_last)//此时LB表已遍历完,将LA中剩余元素加入LC
              *pc++=*pa++;
          while(pb<=pb_last)//此时LA表已遍历完,将LB中剩余元素加入LC
              *pc++=*pb++;
      }
  }
  ```

### 3.有序表的合并（链表）

- ```c
  void MergeList_L(LinkList &La,LinkList &Lb,LinkList &Lc)
  {
      pa=La->next;//pa指针指向La的首元结点
      pb=Lb->next;
      pc=Lc=La;
      while(pa && pb)//两表都不为空时
      {
          if(pa->data<pb->data)
          {
              pc->next=pa;//将pa接在pc之后
              pc=pa;//pc移动到pa
              pa=pa->next;//pa后移
          }
          else
          {
              pc->next=pb;
              pc=pb;
              pb=pb->next;
          }
      }
      pc->next=pa?pa:pb;//pa不为空则指向pa
      free(Lb);//释放Lb的头结点
  }
  ```

## （八）案例分析和实现

### 案例一：一元多项式的运算

- 实现两个多项式加、减、乘运算

### 案例二：稀疏多项式的运算

#### 顺序表实现

- 算法思路：

  1. 创建一个新数组c
  2. 分别从头遍历比较a和b的每一项
     - 指数相同：对应系数相加，若其和不为零，则在c中增加一个新项
     - 指数不相同：则将较小项复制到c中
  3. 当其中一个多项式遍历完毕，将另一个剩余项复制到c中即可

- 问题分析：

  - 顺序存储结构存在问题：
    - 存储空间分配不灵活
    - 运算空间复杂度高

- 算法实现：

  - ```c
    ```

#### 链表实现

- 算法思路：

  1. 创建一个只有头结点的空链表
  2. 根据多项式的个数n，循环n次执行以下操作：
     1. 生成一个新结点s
     2. 输入多项式当前项的系数和指数赋值给新结点s的数据域
     3. 设置一个前驱指针pre，用于指向待找到的第一个大于输出项指数的结点的前驱，pre初值指向头结点
     4. 指针q初始化，指向首元结点
     5. 循链向下逐个比较链表中当前结点与输入项指数，找到第一个大于输出项的结点q
     6. 将输入项结点s插入到结点q之前

- 算法描述：

  - 多项式结点的定义：

    - ```c
      typedef struct PNode
      {
          float coef;//系数
          int expn;//指数
          struct PNode *next;//指针域
      }PNode,*polynomial;
      ```

  - 多项式创建：

    - ```c
      void Createpolyn(Polynomial &P,int n)
      {
          P=(*PNode)malloc(sizeof(PNode));//先建立一个带头结点的单链表
          P->next=NULL;
          for(i=1;i<=n;i++)
          {
              s=(*PNode)malloc(sizeof(PNode));//生成新结点
              //输入系数和指数
              pre=P;//pre用于保存q的前驱，初值为头结点
              q=P->next;//q指向首元结点
              while(q && q->expn<s->expn)
              {
                  pre=q;
                  q=q->next;
              }
              s->next=q;//将输入项s插入到q和其前驱结点pre之间
              pre->next=s;
          }
      }
      ```

  - 多项式相加：

    - 算法步骤：
      1. 指针p1和p2初始化，分别指向Pa和Pb的首元结点
      2. p3指向和多项式的当前节点，初值为Pa的头结点
      3. 当指针p1和p2均未到达相应表尾时，循环比较p1和p2所指结点对应的指数(p1->expn和p2->expn)，有三种情况
         1. 当p1->expn==p2->expn时，则将两个结点中的系数相加
            1. 若和不为零，则修改p1所对应的结点的系数值，同时删除p2所指结点
            2. 若和为零，则删除p1和p2所指结点
         2. 当p1->expn<p2->expn时，则摘取p1所指结点到“和多项式”链表中
         3. 当p1->expn>p2->expn时，则摘取p2所指结点到“和多项式”链表中
      4. 将非空多项式剩余段插入p3所指结点之后
      5. 释放Pb的头结点

### 案例三：图书信息管理

- 结构类型定义

  - ```c
    struct Book
    {
        char id[20];//ISBN
        char name[50];//书名
        int price;//定价
    }
    
    typedef struct
    {
        Book *elem;
        int length;
    }SqList;//顺序表定义
    
    typedef struct LNode
    {
        Book data;
        struct LNode *next;
    }LNode,*LinkList;//链表定义
    ```

# 三.栈和队列

## （一）栈和队列的定义和特点

- 栈和队列是限定插入和删除只能在表的端点进行的线性表
- 栈(stack)是一个特殊的线性表，是限定在一端进行插入和删除的线性表，后进先出(Last In First Out)，简称(LIFO)
  - 栈仅在表尾（栈顶）进行插入、删除
  - 表尾(an)称为栈顶（Top），表头(a1)称为（Base）
  - eg：栈 s=(a1,a2,......an);
  - 插入到栈顶称为入栈，从栈顶删除叫出栈

- 队列(queue)，是一种先进先出(First In First Out)的线性表(FIFO)，在表一端（表尾）插入，在另一端（表头）删除

### 1.栈的应用

- “先进后出，后进先出”

  - 数值转换

  - 表达式求值

  - 括号匹配的检验

  - 八皇后问题

  - 行编辑程序

  - 函数调用

  - 迷宫求解

  - 递归调用的实现

### 2.队列的应用

- “先进先出，后进后出”，类似排队问题
  - 脱机打印：按申请的先后顺序依次输出
  - 多用户系统中，多个用户排队，分别循环使用CPU和主存
  - 按用户的优先级排成队，每个优先级一个队列
  - 实时控制系统，信号按接收的先后顺序依次处理
  - 网络电文传输，按到达的时间先后顺序依次处理

## （二）案例引入

### 案例一：进制转换

### 案例二：括号匹配的检验

### 案例三：表达式求值

### 案例四：舞伴问题

## （三）栈的表示和实现

### 1.栈的抽象数据类型定义

- ```c
  ADT Stack{
      数据对象：
          D={ai|ai∈ElemSet，i=1,2,3,......,n,n>=0};
      数据关系
          R1={<ai-1,ai>|ai-1,ai∈D,i=2,...,n};
      基本操作：初始化、进栈、出栈、取栈顶元素等;
  }ADT Stack
  ```

### 2.栈的基本操作

1. InitStack(&S)
   - 栈的初始化
   - 操作结果：构造一个空栈S
2. DestroyStack(&S)
   - 栈的销毁
   - 初始条件：栈S已经存在
   - 操作结果：栈S被销毁
3. StackEmpty(S)
   - 判定栈S是否为空栈
   - 初始条件：栈S已经存在
   - 操作结果：若栈S为空栈，则返回TURE；否则返回FALSE
4. StackLength(S)
   - 求栈的长度
   - 初始条件：栈S已经存在
   - 操作结果：返回S的元素个数，即栈的长度
5. GetTop(S,&e)
   - 取栈顶元素
   - 初始条件：栈S已经存在，且非空
   - 操作结果：用e返回S的栈顶元素
6. ClearStack(&S)
   - 清空栈
   - 初始条件：栈S已经存在
   - 操作结果：将栈S清空
7. Push(&S,e)
   - 入栈
   - 初始条件：栈S已经存在
   - 操作结果：插入元素e为新的栈顶元素
8. Pop(&S,&e)
   - 出栈
   - 初始条件：栈S已经存在
   - 操作结果：删除栈顶元素an，并用e返回其值

### 3.顺序栈的表示和实现

#### （1）.存储方式：

- 同一般线性表的顺序存储结构完全相同

  - 利用一组地址连续的存储单元依次存放自栈底到栈顶的元素，栈底一般在低地址处

  - 附设top指针，指示栈顶元素在顺序栈中的位置

  - 另设base指针，指示栈底元素在顺序栈中的位置

  - 但是为了方便操作，通常top指示真正的栈顶元素之上的下标地址

  - 另外，用stacksize表示栈可使用的最大容量

  - 空栈标志：top==base

  - 栈满标志：top-base==stacksize

    - 栈满时的处理方法：
      1. 报错，返回操作系统
      2. 分配更大空间作为栈的存储空间，将原栈的内容移入新栈

  - 上溢(overflow)：栈已满，还要压入元素

  - 下溢(underflow)：栈已空，还要弹出元素

  - 注意：上溢是一种错误，使问题无法继续执行；而下溢一般认为是一种结束条件，使问题处理结束

#### （2）.顺序栈的表示（类C）

  - ```c
    #define MAXSIZE 100
    typedef struct
    {
        SElemType *base;//栈底指针
        SElemType *top;//栈顶指针
        int stacksize;//栈可用最大容量
    }SqStack;
    ```

#### （3）.顺序栈的基本操作实现

##### 算法1：顺序栈的初始化

- 类C代码：

  - ```c
    Status InitStack(SqStack &S)
    {
        S.base=(SElemType*)malloc(MAXSIZE*sizeof(SElemType));
        if(!S.base)
            exit(OVERFLOW);//存储分配失败
        S.top=S.base;//栈顶指针等于栈底指针
        S.stacksize=MAXSIZE;
        return OK;
    }
    ```

- C语言实现：

  - ```c
    Status InitSqStack(SqStack* S)
    {
    	S->base = (SElemType*)malloc(MAXSIZE * sizeof(SElemType));
    	if (!S->base)			//S->base为NULL，开辟空间失败
    		exit(OVERFLOW);
    	S->top = S->base;
    	S->stacksize = MAXSIZE;
    	return OK;
    }
    ```

##### 算法2：顺序栈判断是否为空

- 类C代码：

  - ```c
    Status StackEmpty(SqStack S) //若栈为空，返回TURE;若不为空，返回FALSE
    {
        if(S.top == S.base)
            return TURE;
        return FALSE;
    }
    ```

- C语言实现：

  - ```c
    Status IsEmptySqStack(const SqStack* S)
    {
    	if (S->base == S->top)
    		return TRUE;
    	else
    		return FALSE;
    }
    ```

##### 算法3：求顺序栈长度

- 类C代码：

  - ```c
    int StackLength(SqStack S)
    {
        return S.top-S.base;//涉及指针减指针这一特殊情况
    }
    ```

- C语言实现：

  - ```c
    ```

  - 

##### 算法4：清空栈

- 类C代码：

  - ```c
    Status ClearStack(SqStack S)
    {
        if(S.base)
            S.top=S.base;//直接将栈顶指针指向栈底指针
        return OK;
    }
    ```

- C语言实现：

  - ```c
    Status ClearSqStack(SqStack* S)
    {
    	if(S->base)
    		S->top = S->base;
    	return OK;
    }
    ```

  - 

##### 算法5：销毁栈

- 类C代码：

  - ```c
    Status DestroyStack(SqStack &S)
    {
        if(S.base)
        {
            free(S.base);
            S.stacksize=0 ;
            S.base=S.top=NULL;
        }
        return OK;
    }
    ```

- C语言实现：

  - ```c
    Status DestroySqStack(SqStack* S)
    {
    	if (!S->base)
    		return ERROR;
    	free(S->base);
    	S->top = S->base = NULL;
    	S->stacksize = 0;
    	return OK;
    }
    ```

##### 算法6：顺序栈的入栈

- 类C代码：

  - ```c
    /*
    1.判断是否栈满，若满则返回上溢
    2.元素e压入栈顶
    3.栈顶指针加一
    */
    Status Push(SqStack &S,SElemType e)
    {
        if(S.top-S.base == stacksize)
        	return ERROR;//或OVERFLOW
        *S.top=e;
        S.top++;
        return OK;
    }
    ```

- C语言实现：

  - ```c
    Status Push(SqStack* S, SElemType* e)
    {
    	if (!S->base || S->top - S->base == S->stacksize)		//栈为NULL,或者上溢
    		return ERROR;
    	*(S->top++) = *e;
    	return OK;
    }
    ```

##### 算法7：顺序栈的出栈

- 类C代码：

  - ```c
    /*
    1.判断是否栈空，若空则下溢
    2.获取栈顶元素e
    3.栈顶指针减一
    */
    Status Pop(SqStack &S,SElemType &e)
    {
        if(S.top == S.base)
        	return ERROR;
        --S.top;
        e=*S.top;
        return OK;
    }
    ```

- C语言实现：

  - ```c
    Status Pop(SqStack* S, SElemType* e)
    {
    	if (!S->base || S->top == S->base)						//栈为NULL,或者下溢
    		return ERROR;
        --S->top;
    	*e = *S->top;
    	return OK;
    }
    ```

##### 算法8：显示栈

- C语言实现：

  - ```c
    void ShowSqStack(const SqStack* S)
    {
    	if (!S->base || S->top == S->base)
    		printf("SqStack is Empty!\n");
    	SElemType* p = S->top;
    	while (p-- != S->base)
    	{
    		printf("%d ", *p);
    	}
    	putchar('\n');
    }
    ```

### 4.链栈的表示和实现

#### （1）.链栈的表示

- 链栈是操作受限的单链表，只能在链表头部进行操作

- ```c
  typedef struct StackNode
  {
      SElemType data;
      struct StackNode *next;
  }StackNode,*LinkStack;
  
  LinkNode S;//
  ```

- 链表的头指针就是栈顶

- 不需要头结点

- 基本不存在栈满的情况

- 空栈相当于头指针指向空

- 插入和删除仅在栈顶处执行

#### （2）.链栈的基本操作实现

##### 算法1：链栈的初始化

- 类C代码：

  - ```c
    void InitStack(LinkStack &S)
    {
        //构建一个空栈，栈顶指针置空
        S=NULL;
        return OK;
    }
    ```

- C语言实现：

  - ```c
    //带有头结点（？？？），应该不需要
    Status InitLinkStack(LinkStack* S)
    {
    	*S = (LinkStack)malloc(sizeof(StackNode));
    	if (!S)			//开辟空间失败
    		return ERROR;
    	(*S)->next = NULL;//(???)
    	return OK;
    }
    ```

  - ```c
    //不带头结点
    void InitStack(LinkStack* S)
    {
    	*S=NULL;//不需要头结点
    }
    ```

##### 算法2：判断链栈是否为空

- 类C代码：

  - ```c
    Status StackEmpty(LinkStack S)
    {
        if(S == NULL)
            return TURE;
        return FALSE;
    }
    ```

- C语言实现：

  - ```c
    //带头结点,地址传递
    Status IsEmptyLinkStack(LinkStack* S)
    {
    	if ((*S)->next == NULL)	
    		return TRUE;
    	return FALSE;
    }
    ```

  - ```c
    //不带头结点，值传递
    Status stackEmpty(LinkStack S)
    {
    	if(S == NULL)
    		return TURE;
    	return FALSE;
    }
    ```

##### 算法3：链栈的入栈

- 类C代码：

  - ```c
    Status StackPush(LinkStack &S,SElemType e)
    {
        p=(StackNode*)malloc(sizeof(StackNode));//生成新结点
        p->data=e;//将新结点数据域置为e
        p-next=S;//将新结点插入栈顶
        S=p;//修改栈顶指针
        return OK;
    }
    ```

- C语言实现：

  - ```c
    Status Push(LinkStack* S, SElemType e)
    {
    	StackNode* new = (StackNode*)malloc(sizeof(StackNode));
    	new->data = e;
    	new->next = *S;
    	(*S) = new;
    	return OK;
    }
    ```

  - 

##### 算法4：链栈的出栈

- 类C代码：

  - ```c
    Status StackPop(LinkStack &S,SElemType &e)
    {
        if(S == NULL)
            return ERROR;
        e=S->data;
        p=S;//新建一个结点存放要释放的栈顶结点
        S=S->next;//栈顶指针下移
        free(p);//释放要删除的结点
        return OK;
    }
    ```

- C语言实现：

  - ```c
    Status Pop(LinkStack* S, SElemType* e)
    {
    	if ((*S) == NULL)			//判断链栈下溢
    		return ERROR;
    	StackNode* p = *S;
    	*e = p->data;
    	*S = p->next;
    	free(p);					//释放栈顶空间
    }
    ```

##### 算法5：取栈顶元素

- 类C代码：

  - ```c
    SElemType GetTop(LinkStack S)
    {
        if(S != NULL)
            return S->data;
    }
    ```

- C语言实现：

  - ```c
    //有头结点，二级指针
    SElemType GetTop(LinkStack* S)
    {
    	if ((*S)->next)
    		return (*S)->data;
    }
    ```

  - ```c
    //无头结点，二级指针
    SElemType GetTop(LinkStack* S)
    {
    	if (*S)
    		return (*S)->data;
    }
    ```

  - ```c
    //无头结点，一级指针
    SElemType GetTop(LinkStack S)
    {
    	if (S)
    		return S->data;
    }
    ```

##### 算法6：显示栈

- C语言实现：

  - ```c
    //有头结点，二级指针
    void ShowLinkStack(const LinkStack* S)
    {
    	if (!(*S)->next)
    	{
    		printf("The LinkStack is Empty\n");
    		return;
    	}
    	else if (!(*S))
    	{
    		printf("The LinkStack dosen't  exsist\n");
    	}
    	StackNode* p;
    	p = *S;
    	while (p->next)
    	{
    		printf("%d ", p->data);
    		p = p->next;
    	}
    	putchar('\n');
    }
    ```

## （四）栈和递归

### 1.递归的定义

- 若一个对象部分的包含他自己，或用他自己给自己定义，则称这个对象是递归的
- 若一个过程之间或间接地调用自己，则称这个过程是递归的过程
  - ed：递归求n的阶乘

### 2.常用递归方法的情况

1. 递归定义的数学函数
   1. 阶乘函数
   2. 斐波那契数列
2. 具有递归特性的数据结构
   1. 二叉树
   2. 广义表
3. 可递归求解的问题
   1. 迷宫问题
   2. 汉诺塔问题

### 3.递归问题

- 用分治法求解
  - 分治法：对于一个较复杂的问题，能够分解成几个相对简单的且解法相同或类似的子问题来求解
- 必备的三个条件：
  1. 能够将一个问题转变成一个新问题，且新问题与原问题的解法相同或类同，不同的仅是处理的对象，且这些处理对象是有变化规律的
  2. 可以通过上述转化使问题简化
  3. 必须有一个明确的递归出口，或称为递归的边界

### 4.函数调用过程

- 调用前，系统完成：
  1. 将实参、返回地址等传递给被调用函数
  2. 为被调函数的局部变量分配存储区域
  3. 将控制转移到被调函数的入口
- 调用后，系统完成：
  1. 保存被调函数的计算结果
  2. 释放被调函数的数据区
  3. 依照被调函数保存的返回地址将控制转移到被调函数

## （五）队列的表示和实现

### 1. 队列的抽象数据类型：

- ```c
  ```

### 2. 顺序队列的基本操作实现

#### （1）.队列的顺序表示

- 用一维数组base[MAXSIZE]

- 循环队列的结构

  - ```c
    #define MAXSIZE 100//最大队列长度
    typedef struct
    {
    	QElemType *base;//初始化动态分配存储空间
        int front;//头指针（实际是队头元素下标）
        int rear;//尾指针（实际是队尾元素下标）
    }SqQueue;
    ```

- 初始:

  - ```c
    cfront=rear=0
    ```

- 入队

  - ```c
    base[rear]=x;
    rear++;
    ```

- 出队

  - ```c
    x=base[front];
    front++;
    //空队标志
    front==rear;
    ```

- 真溢出

  - ```c
    front=0;
    rear=MAXSIZE;
    ```

- 假溢出

  - ```c
    front!=0;
    rear=MAXSIZE;
    ```

#### （2）.解决假上溢的方法

1. 将队中元素依次向队头方向移动

   - 缺点：浪费时间，每移动一次，队中元素都要移动

2. 将队空间想象成一个循环的表，即分配给队列的m个存储单元可以循环使用，当rear为MAXSIZE时，若向量的开始端空着，则又可以开始从头使用空着的空间，当front为MAXSIZE时，也是一样

   - 引入循环队列：base[0]接在base[MAXSIZE-1]之后，若rear+1==M，则令rear=0;

     - 实现方法：利用模运算

     - 插入元素：

       - ```c
         Q.base[Q.rear]=x;
         Q.rear=(Q.rear+1)%MAXSIZE;
         ```

     - 删除元素：

       - ```c
         x=Q.base[Q.front];
         Q.front=(Q.front+1)%MAXSIZE;
         ```

     - 循环队列队空队满标志冲突
     
       - front==rear
       - 解决方案：
         1. 另外设一个标志以区别队空队满
         2. 另设一个变量，记录元素个数
         3. 少用一个元素空间（采用）
            - 队空：front==rear
            - 队满：（rear+1）%MAXSIZE==front
     

#### （3）.循环队列的操作

##### 算法1：队列的初始化

- 类C代码：

  - ```c
    Status InitQueue(SqQueue &Q)
    {
        Q.base=(QElemType*)malloc(MAXSIZE*sizeof(QElemType));//分配数组空间
        if(!Q.base)
            exit(OVERFLOW);//存储分配失败
        Q.front=Q.rear=0;//头指针尾指针都置为零，队列为空
        return OK;
    }
    ```

- C语言实现：

  - ```c
    Status InitSqQueue(SqQueue* Q)
    {
    	Q->base = (QElemType*)malloc(MAXQSIZE * sizeof(QElemType));
    	if (!Q->base)
    		return ERROR;
    	Q->front = Q->rear = 0;
    	return OK;
    }
    ```

##### 算法2：求队列长度

- 类C代码：

  - ```c
    int QueueLength(SqQueue Q)
    {
        return (Q.rear-Q.front+MAXSIZE)%MAXSIZE;//解决了循环队列中尾指针到头指针前面的情况
    }
    ```

- C语言实现：

  - ```c
    //传址调用
    int GetLength(SqQueue* Q)
    {
    	return ((Q->rear - Q->front + MAXSIZE) % MAXSIZE);
    }
    ```

  - ```c
    //传值调用
    int QueueLength(SqQueue Q)
    {
        return (Q.rear - Q.front + MAXSIZE) % MAXSIZE;
    }
    ```

##### 算法3：循环队列入队

- 类C代码：

  - ```c
    Status EnQueue(SqQueue &Q,QElemType e)
    {
        if((Q.rear + 1) % MAXSIZE == front)
            return ERROR;//判断队满
        Q.base[Q.rear] = e;//新元素加入队尾
        Q.rear = (Q.rear + 1) % MAXSIZE;
        return OK;
    }
    ```

- C语言实现：

  - ```c
    Status EnQueue(SqQueue* Q, QElemType* e)
    {
    	if ((Q->rear + 1) % MAXQSIZE == Q->front)		//出现上溢
    		return ERROR;
    	Q->base[Q->rear] = *e;
    	Q->rear = (Q->rear + 1) % MAXQSIZE;
    	return OK;
    }
    ```

##### 算法4：循环队列出队

- 类C代码：

  - ```c
    Status OutQueue(SqQueue &Q,QElemType &e)
    {
        if(Q.rear == Q.front)
            return ERROR;//判断队空
        e=Q.base[front];//保存队头元素
        Q.front=(Q.front+1)%MAXSIZE;//队头指针加一（但不会超过MAXSIZE-1）
        return OK;
    }
    ```

- C语言实现：

  - ```c
    Status DeQueue(SqQueue* Q, QElemType* e)
    {
    	if (Q->front == Q->rear)				//出现下溢
    		return ERROR;
    	*e = Q->base[Q->front];
    	Q->front = (Q->front + 1) % MAXQSIZE;
    	return OK;
    }
    ```

##### 算法5：取队头元素

- 类C代码：

  - ```c
    QElemType GetHead(SqQueue Q)
    {
        if(Q.front==Q.rear)
            return ERROR;
        return Q.base[Q.front];//返回队头元素的值，队头指针不动
    }
    ```

- C语言实现：

  - ```c
    //传址调用
    QElemType GetHead(SqQueue* Q)
    {
    	if (Q->rear == Q->front)
             return ERROR;
    	return Q->base[Q->front];
    }
    ```

  - ```c
    //传值调用
    QElemType GetHead(SqQueue Q)
    {
        if(Q.front==Q.rear)
            return ERROR;
        return Q.base[Q.front];
    }
    ```

##### 算法6：销毁队列

- C语言实现：

  - ```c
    Status DestoryQueue(SqQueue* Q)
    {
    	if (!(Q->base))
    		return ERROR;
    	free(Q->base);
    	Q->front = Q->rear = 0;
    	return OK;
    }
    ```

##### 算法7：显示队列

- C语言实现：

  - ```c
    void ShowSqQueue(SqQueue Q)
    {
    	if (Q.front == Q.rear)
    	{
    		printf("The SqQueue is Empty\n");
    		return;
    	}
    	while (Q.rear != Q.front)
    	{
    		printf("%d ", Q.base[Q.front]);
    		Q.front = (Q.front + 1) % MAXQSIZE;
    	}
    	putchar('\n');
    }
    ```

### 3.链式队列的表示和实现

- 若用户无法估计所用队列的长度，则采用链队列

#### （1）.链队列的类型定义

- ```c
  tepedef struct QNode
  {
      QElemType data;
      struct QNode *next;
  }QNode,*QueuePtr;//链队列结点，链队列指针
  typedef struct
  {
      QueuePtr front;//队头指针
      QueuePtr rear;//队尾指针
  }LinkQueue;//链队列
  ```

#### （2）.链队列的基本操作

##### 算法1：链队列初始化

- 类C代码：

  - ```c
    Status InitQueue(LinkQueue &Q)
    {
        Q.front=Q.rear=(QNode*)malloc(sizeof(QNode));
        if(!Q.front)
            exit(OVERFLOW);
        Q.front->next=NULL;//队头指针置空
        return OK;
    }
    ```

- C语言实现：

  - ```c
    Status InitLinkQueue(LinkQueue* Q)
    {
    	Q->front = Q->rear = (QNode*)malloc(sizeof(QNode));
    	if (!Q->rear)
    		return ERROR;
    	Q->rear->next = NULL;
    	return OK;
    }
    ```

##### 算法2：销毁链队列

- 类C代码：

  - ```c
    //从队头结点开始依次释放所有结点
    Status DestroyQueue(LinkQueue &Q)
    {
        while(Q.front)
        {
            p=Q.front->next;//存放下一个结点，否则直接删除Q.front会找不到下一结点
            free(Q.front);
            Q.front=p;//移动队头结点
        }
        return OK;
    }
    ```

- C语言实现：

  - ```c
    Status DestoryLinkQueue(LinkQueue* Q)
    {
    	QNode* p;
    	while (Q->front)
    	{
    		p = Q->front->next;
    		free(Q->front);
    		Q->front = p;
    	}
    	return OK;
    }
    ```

##### 算法3：链队列的入队

- 类C代码：

  - ```c
    Status EnQueue(LinkQueue &Q,QElemType e)
    {
        p=(QNode*)malloc(sizeof(QNode));
        if(!p)
            exit(OVERFLOW);
        if((Q.rear+1)%MAXSIZE == Q.front)
            return ERROR;
        p->data=e;
        p->next=NULL;
        Q.rear->next=p;
        Q.rear=p;
        return OK;
    }
    ```

- C语言实现：

  - ```c
    Status EnQueue(LinkQueue* Q, QElemType* e)
    {
    	QNode* new = (QNode*)malloc(sizeof(QNode));
    	new->data = *e;
    	new->next = Q->rear->next;
    	Q->rear->next = new;
    	Q->rear = new;		//更新队列尾指针
    	return OK;
    }
    ```

##### 算法4：链队列的出队

- 类C代码：

  - ```c
    Status DeQueue(LinkQueue &Q,QElemType &e)
    {
        if(Q.front == Q.rear)
            return ERROR;//判断队空
        p=Q.front->next;
        e=p->data;
        Q.front->next=p->next;
        if(Q.rear == p)//如果链队列中元素个数为零了，还需要修改尾指针
            Q.rear=Q.front;
        free(p);
        return OK;
    }
    ```

- C语言实现：

  - ```c
    Status DeLinkQueue(LinkQueue* Q, QElemType* e)
    {
    	if (Q->front == Q->rear)
    		return ERROR;
    	QNode* p = Q->front->next;
    	*e = p->data;
    	Q->front->next = p->next;
    	if (Q->rear == p)
    		Q->front = Q->rear;
    	free(p);
    	return OK;
    }
    ```

##### 算法5：求链队列的队头元素

- 类C代码：

  - ```c
    Status GetHead(LinkQueue Q,QElemType &e)
    {
        if(Q.front == Q.rear)
            return ERROR;//判断队空
        e=Q.front->next->data;
        return OK;
    }
    ```

- C语言实现：

  - ```c
    QElemType GetHead(LinkQueue* Q)
    {
    	if(Q->front != Q->rear)
    		return Q->front->next->data;
    }
    ```

  - ```c
    Status GetHead(LinkQueue Q,QElemType *e)
    {
        if(Q.front == Q.rear)
            return ERROR;//判断队空
        *e = Q.front->next->data;
        return OK;
    }
    ```

# 四.串、数组和广义表

## （一）串

### 1.串的定义：

- 零个或多个任意字符组成的有限序列
- eg：S="abcdefg" (n>=0)
  - S为串名
  - abcdefg为串值
  - n为串长；若n为零，则称为空串
- 几个术语：
  - 空格串：是只包含空格的串，可以有一个或多个空格
    - 注意它与空串的区别，空格串是有内容有长度的，而且可以不止一个空格
  - 子串与主串：串中任意个数的连续字符组成的子序列称为该串的子串，相应地，包含子串的串称为主串
    - 真字串：不包含自身的所有子串
  - 字符位置：字符在序列中的序号为该字符在串中的位置
  - 子串位置：子串的第一个字符在主串中的序号
  - 串相等：当且仅当两个串的长度相等且对应位置上的字符都相同时，这两个串才相等
    - 所有的空串都相等

### 2. 案例引入

- 案例一：病毒感染检测
  - 案例实现：
    - 对于每一个待检测的任务，假设病毒DNA序列的长度是m，因为病毒DNA序列是环状的，为了线性取到每个可行的长度为m的字符串，可将存储病毒DNA序列的字符串长度扩大到2m，将病毒DNA序列连续存储两次
    - 然后循环m次，依次取得每个长度为m的环状字符串，将此字符作为模式串，将人的DNA序列作为主串，调用BF算法进行模式匹配
    - 只要匹配成功，即可终止循环，表明该人感染了病毒；否则，循环m次结束后，可通过BF算法的返回值判断该人是否感染了对应的病毒



### 3. 串的抽象数据类型定义

- ```c
  ADT String
  {
      数据对象：D={ai|ai∈CharacterSet,i=1,2,3,...,n,n>=0}
      数据关系：
      基本操作：
          1.StrAssign(&T,chars)//串赋值
          2.StrCompare(S,T)//串比较
          3.StrLength(S)//求串长
          4.Concat(&T,S1,S2)//串连结
          5.SubString(&Sub,pos,len)//求子串
          6.StrCopy(&T,S)//串拷贝
          7.StrEmpty(S)//串判空
          8.ClearString(&S)//清空串
          9.lndex(S,T,pos)//子串的位置
          10.Replace(&S,T,V)//串替换
          11.StrInsert(&S,pos,T)//子串插入
          12.StrDelete(&S,pos,len)//子串删除
          13.DestroyString(&S)//串销毁
  }ADT String
  ```

### 4. 顺序串

#### 顺序串的存储结构

- 用的更多，因为字符串操作很少需要插入删除

- ```c
  #define MAXSIZE 255
  typedef struct
  {
      char ch[MAXSIZE+1];//存储串的一维数组，下标为0的位置闲置（在某些算法中会带来简便），从下标为1的位置开始存放
      int length;//串的当前长度
  }SString;//第一个S表示“顺序”
  ```

### 5.链串

#### 链串的存储结构---块链结构

- ```c
  #define CHUNKSIZE 80 //块的大小由用户定义
  typedef struct Chunk
  {
      char ch[CHUNKSIZE];
      struct Chunk *next;
  }Chunk;
  typedef struct
  {
      Chunk *head,*tail; //串的头指针和尾指针
      int curlen; //串的当前长度
  }LString; //字符串的块链结构
  ```

  - 优点：操作方便
  - 缺点：存储密度较低
  - 可以将多个字符存放在一个结点内，以克服存储密度较低的缺点

### 6.串的模式匹配算法（BF和KMP)

- 算法目的：

  - 确定主串中所含子串第一个出现的位置（定位）

- 算法应用：

  - 搜索引擎、拼写检查、语言翻译、数据压缩

- 算法种类：

  - BF算法（Brute-Force，又称古典的、经典的、朴素的、穷举的）

    - 又称简单匹配算法，采用穷举的思路

    - 算法思路：从S（主串：正文串）的每一个字符开始依次与T（子串：模式）的字符进行匹配

      - lndex(S,T,pos)
        - 将主串的第pos个字符与模式串的第一个字符比较
          - 若相等，继续逐个比较后续字符
          - 若不相等，从主串下一个字符起，重新与模式串的第一个字符比较
        - 直到主串的一个连续子串字符序列与模式串相等，返回值为S与T中匹配的子序列第一个字符的序号，即匹配成功
        - 否则，匹配失败，返回0

    - ```c
      int lndex_BF(SString S,SString T)
      {
          int i=1,j=1;
          while(i<=S.length && j<=T.length)
          {
              if(S.ch[i] == T.ch[j]) //比较成功时，主串和子串依次匹配下一个字符
                 {
                     ++i;
                     ++j;
                 }
              else //主串、子串指针回溯，重新开始下一次匹配      
              {
                  i=i-j+2;//i-(j-1)+1
                  j=1;
              }
          }
          if(j >= T.length)
              return i-T.length;//返回匹配的第一个字符下标
          return 0;//未匹配成功
      }	
      ```

    - BF算法的时间复杂度：

      - 若主串长度为n，子串长度为n，最坏情况下：主串前面n-m个位置都匹配到了子串的最后一位，即n-m个位置各比较了m次，最后m位也各比较了1次
        - 总次数为：(n-m)*m+m
        - 若m<<n，则算法的时间复杂度为Q(n*m)

  - KMP算法（特点：速度快）

    - 较BF算法有较大改进，主串S的指针i不再回溯，可提速至O(m+n)

    - 需要定义next[j]函数，表明当模式中第i个字符与主串中相应字符不匹配时，在模式中需重新和主串中该字符进行比较的字符位置

      - next[j]	=
        - max{ k | 1<k<j ,且 p1p2p3p4...pk-1 = pj-k-1...pj-1}

        - 0    当j=1时
    
        - 1    其他情况
    
    - ```c
      int lndex_KMP(SString S,SString T)
      {
          int i=1,j=1;
          while(i<=S.length && j<=T.length)
          {
              if(S.ch[i] == T.ch[j]) //比较成功时，主串和子串依次匹配下一个字符
                 {
                     ++i;
                     ++j;
                 }
              else //主串、子串指针回溯，重新开始下一次匹配      
              {
                  j=next[j];
              }
          }
          if(j >= T.length)
              return i-T.length;//返回匹配的第一个字符下标
          return 0;//未匹配成功
      }	
      void get_next(SString T,int &next[])
      {
          i=0;
          next[1]=0;
          j=0;
          while(i<T.length)
          {
              if(j==0 || T.ch[i]==T.ch[j])
              {
                  ++i;
                  ++j;
                  next[i]=j;
              }
              else
                  j=next[j];
          }
      }
      ```
  
  

## （二）数组

- 结论：线性表结构是数组元素的一个特例，而数组结构又是线性表结构的拓展

- 数组特点：结构固定，定义后维数和维界不再改变

- 数组基本操作：

  - 除了结构的初始化和销毁之外，只有去元素和修改元素值的操作

### 1. n维数组的抽象数据类型

- ```c
  ADT Array
  {
      数据对象：
      数据关系：
      基本操作：
          1.InitArray(&A,n,bound1,...,boundn) //构建数组A
          2.DestroyArray(&A) //销毁数组A
          3.Value(A,&e,index1,...,indexn) //去数组元素值
          4.Assign(A,&e,index1,...,indexn) //给数组元素赋值
  }ADT Array
  ```

### 2.数组的顺序存储

- 一般都采用顺序存储结构来表示数组
- 数组可以是多维的，但存储数据元素的内存单元地址的一维的，因此在存储数据结构之前，需要解决多维关系映射到一维关系的问题
- 二维数组两种顺序存储方式：
  - 以行序为主序（低下标优先）：BASIC、COBOL、PASCAL、Java、C
    - `数组元素a[i][j]的存储位置是:LOC(i,j)=LOC(0,0)+(n*i+j)*L`
  - 以行序为主序（高下标优先）：FORTRAN

### 3.特殊矩阵的压缩存储

- 不适宜常规存储的矩阵：值相同的元素且呈某种规律分布；零元素多
- 矩阵的压缩存储：为多个相同的非零元素只分配一个存储空间；对零元素不分配空间
- 什么样的矩阵能压缩存储：
  - 对称矩阵
    - 特点：a(ij)=a(ji)    (沿对角线对称)
    - 存储方法：只存储下三角（或上三角）（包括主对角线）的元素。共占用n(n+1)/2个元素空间
    - 存储结构：以行序为主序将元素存在一个一维数组sa[n(n+1)/2]中
  - 对角矩阵
    - 特点：在n×n的方阵中，所有元素都集中在以主对角线为中心的带状区域中，区域外的值全为0
      - 常见的有：三对角矩阵、五对角矩阵。七对角矩阵
      - 存储方法：以对角线的顺序存储
  - 三角矩阵
    - 特点：对角线以上（或以下）的数据元素（不包括对角线）全部为常数C
    - 存储方法：重复元素共享一个存储空间，共占用n(n+1)/2+1个元素空间
    - 存储结构：以行序为主序将元素存在一个一维数组sa[n(n+1)/2+1]中
    - 下三角矩阵的元素位序k=
      - i*(i-1)/2+j       i>=j（对角线及下半区）
      - n(n+1)/2+1    i<j（上半区）
    - 上三角矩阵的元素位序k=
      - (i-1)*(2n-i)/2+j-i+1    i<=j  (对角线及上半区）    ***未推导
      - n(n+1)/2+1    i<j（下半区）
  - 稀疏矩阵：矩阵中非零元素少于百分之五
    - 方法一：三元组顺序表（又称有序的双下标法）
      - 压缩存储原则：存各非零元的值，行列位置和矩阵的行列数
      - 注意：为更可靠描述，通常再加一个总体信息，即总行数、总列数、总元素数
      - 优点：非零元在表中按行序有序储存，因此便于进行依行顺序处理的矩阵运算
      - 缺点：不能随机存取，若按行号存取某一行中的非零元，则需从头开始查找
    - 方法二：十字链表
      - 优点：能够灵活地插入因运算产生的的非零元素，删除运算产生的新零元素
      - 在十字链表中，矩阵的每一个非零元素用一个结点表示，该结点除了（行，列，数值），还要有两个域：
        - right：用于链接同一行的下一个非零元素
        - down：用于链接同一列的下一个非零元素

## （三）广义表

### 1.广义表的定义

- 广义表（又称列表Lists），是n>=0个元素a0,a1,a2,...,an-1的有限序列，其中每个元素是一个原子或一个广义表
- 广义表通常记为  LS=(a1,a2,a3,...,an)
  - LS为表名，n为长度，每一个ai为表的元素
  - 表头：若LS非空，则第一个元素a1为表头
    - 记作：head(LS)=a1    (注意：表头可以是原子，也可以是子表)
  - 表尾：除表头的其他元素组成的表
    - 记作：tail(LS)=(a2,a3,...,an)   (注意：表尾不是最后一个元素，而是一个子表)

### 2.广义表的性质

- 广义表中的数据元素有相对次序，一个直接前驱和一个直接后继
- 广义表的长度定义为最外层所包含元素的个数
- 广义表的深度定义为该广义表展开后所包含的括号重数
  - 注：原子的深度为0，空表的深度为1
- 广义表可以和其他广义表共享
- 广义表可以是一个递归的表
- 广义表是一个多层次的结构，广义表的元素可以是单元素、也可以是子表，子表的元素还可以是子表

### 3.广义表和线性表的区别

- 广义表可以看成是线性表的推广，线性表是广义表的特例

### 4.广义表的运算

- 求表头运算GetHead(L)：非空广义表的第一个元素可以是一个原子，也可以是一个子表
- 求表尾运算GetTail(L)：非空广义表除去表头元素以外其他元素所构成的表，表尾一定是一个表

# 五.树和二叉树

## （一）树和二叉树的定义

### 1.树的定义

- 树是(Tree)n(n>=0)个结点的有限集（树的定义是一个递归的定义）
  - 若n=0，称为空树
  - n>0，则它满足两个条件：
    1. 有且仅有一个特定的称为根(Root)的结点
    2. 其余结点可分为m个互不相交的有限集T1,T2,T3...,Tm,其中每个集合本身又是一棵树，并称为根的子树(SubTree)

### 2.树的基本术语

- 根结点：非空树中无直接前驱的结点
- 结点的度：结点拥有的子树数
- 树的度：树内各结点的度的最大值
- 叶子结点（终端结点）：度为零的结点
- 分支结点/非终端结点：度！=0的结点
- 内部节点：根节点之外的分支节点
- 结点的子树的根称为该结点的**孩子**，该结点称为孩子的**双亲**
- 兄弟结点：有共同双亲的结点
- 堂兄弟结点：双亲在同一层的结点
- 结点的祖先：从根到该节点所经分支上的任一结点
- 结点的子孙：以该结点为根的子树中的任一结点
- 树的深度：树中结点的最大层次
- 有序树：树中结点的各子树从左至右有次序（最左边为第一个孩子）
- 无序树：树中结点的各子树无次序
- 森林：m(m>=0)棵互不相交的树的集合
  - 把树的结点删除，树就变成了森林
  - 给森林中的各子树加上一个双亲结点，森林就变成了树
  - 一棵树可以看作是一个特殊的森林
  - 树一定是森林，森林不一定是树


### 3.二叉树的定义

- 二叉树是n(n>=0)个结点的有限集，它由空集或由一个根结点及两颗互不相交的分别称为左子树和右子树的二叉树组成
  - 特点：
    1. 每个结点最多有两个孩子（二叉树中不存在在度大于2的结点）
    2. 子树有左右之分，次序不能颠倒
    3. 二叉树可以是空集，根可以有空的左子树或空的右子树
  - 注意：二叉树不是树的特殊情况，它们是两个概念
    - 二叉树结点的子树要区分左子树和右子树，即使只有一棵子树也要说明它是左子树还是右子树
    - 树当结点只有一个孩子是，无须区分它是左是右
    - ed：具有三个结点的二叉树有5种不同形态，普通树则只有两种不同形态

- 为什么要重点研究二叉树？
  - 普通树若不转化为二叉树，则运算很难实现
  - 二叉树结构最简单，规律性最强
  - 所有的树都可以转化成唯一对应的二叉树，不失一般性

## （二）案例引入

### 案例一：数据压缩问题

- 将数据文件转换成由0、1组成的二进制编码

### 案例二：利用二叉树求解表达式的值

- 

## （三）树和二叉树的抽象数据类型定义

- ```c
  ADT BinaryTree
  {
      数据对象：D是具有相同特性的数据元素的集合
      数据关系：若D=Ø，则R=Ø;
          	 若D!=Ø,则R={H};H是如下二元关系：
                   1.//关于树的说明
                   2.//关于子树不相交的说明
                   3.//关于数据元素的说明
                   4.//关于左子树和右子树的说明
      基本操作P：  
               CreateBiTree(&T,definition);//建立二叉树
      		PreOrderTraverse(T);//先序遍历
      		InOrderTraverse(T);//中序遍历
      		PostOrderTraverse(T);//后序遍历
      		......
  }ADT BinaryTree
  ```

## （四）二叉树的性质和存储结构

### 1.二叉树的性质（1，2，3）

1. 在二叉树的第i层上至多有2的i-1次方个结点（第1层：2的0次方；第2层：2的1次方）
2. 深度为k的结点至多有2的k次方减1个结点（等比数列），至少有k个结点
3. 对任何一颗二叉树T，如果其叶子节点为n0,度为2的结点个数为n2，则n0=n2+1   （？？？）

### 2.两种特殊的二叉树

#### （1）.满二叉树

- 定义：一棵深度为k，且有2的k次方减1个结点的二叉树
- 特点：
  1. 每一层上的结点数都是最大结点数
  2. 叶子结点全部在最底层
- 对满二叉树结点位置进行编号：
  - 编号规则：从根节点开始，自上而下，自左至右
  - 每一个结点位置都有元素
- 满二叉树在同样深度的二叉树中结点个数最多，叶子结点个数也最多

#### （2）.完全二叉树

- 深度为k的具有n个结点的二叉树，当且仅当其每个结点都与深度为k的满二叉树中编号为1~n的结点一一对应时，称为完全二叉树
- 注：在满二叉树中，从最后一个结点开始，*连续*去掉任意个结点，得到的就是一棵完全二叉树
- 特点：
  1. 叶子结点只可能分布在层次最大的两层上
  2. 对任一结点，如果其右子树的最大层次为i，则其左子树最大层次必为i或i-1
- 满二叉树一定是完全二叉树，完全二叉树不一定是满二叉树

### 3.完全二叉树的性质（4，5）

4. 具有n个结点的完全二叉树的深度为：（不大于logn的最大整数+1）
5. 完全二叉树中双亲结点编号与孩子结点的编号之间的关系，如果对一棵有n个结点的完全二叉树的结点按层序编号，则对任一结点：
   1. 如果i=1，则结点i是二叉树的根，无双亲；如果i>1，则其双亲是结点：（不大于i/2的 最大整数)
   2. 如果2i>n，则结点i是叶子结点，无左孩子；否则，其左孩子是结点：2i
   3. 如果2i+1>n，则结点i无右孩子；否则，其右孩子是结点2i+1

### 4.二叉树的顺序存储

- 实现：按二叉树的结点层次编号，依次存放二叉树中的数据元素

  - ```c
    #define MAXSIZE 100
    typedef TElemType SqBiTree[MAXSIZE];
    SqBiTree bt;
    ```

- 二叉树顺序存储缺点：

  - 最坏情况：深度为k且只有k个结点的单支树，需要2的k次方减1的一维数组

- 特点：结点关系蕴含在其存储位置中，浪费空间，适合满二叉树和完全二叉树

### 5.二叉树的链式存储结构

#### (1). 二叉链表

- 二叉链表中空指针域的数量（假设n个结点）
  - 具有n个结点的二叉链表中，一共有2n个指针域；n个结点一共有n-1个孩子，即有n-1个指针用来指向结点的左右孩子，其余n+1个指针域为空

- ```c
  //二叉链表
  typedef struct BiNode
  {
      TElemType data;
      struct BiNode *lchild,*rchild;//左右孩子指针
  }BiNode,*BiTree0
  ```

#### (2).三叉链表

- ```c
  //三叉链表
  typedef struct TriTNode
  {
      TElemType data;
      struct TriTNode *lchild,*parent *rchild;
  }TriTNode,*TriTree;
  ```

## （五）遍历二叉树和线索二叉树

### 1.遍历的定义：

- 顺着某一条搜索路径巡防二叉树中的结点，使得每个结点均被访问一次，而且仅访问一次

### 2.遍历的目的：

- 得到树中所有结点的一个线性排列

### 3.遍历的用途：

- 树结构的插入、删除、修改、查找和排序的前提，是二叉树一切运算的基础和核心

### 4.遍历二叉树算法描述：

- 根结点（D）
- 左子树（L）
- 右子树（R）

#### (1).DLR---先序遍历

- 若二叉树为空，则空操作；否则：
  1. 访问根节点
  2. 先序遍历左子树
  3. 先序遍历右子树
  
- 先序遍历算法(递归实现)

  - ```c
    Status PreOrderTraverse(BiTree T)
    {
        if(T == NULL)
            return OK;//空二叉树
        visit(T);//访问根节点，可以是输出或其他操作
        PreOrderTraverse(T->lchild);//递归遍历左子树
        PreOrderTraverse(T->rchild);//递归遍历右子树
    }
    ```

#### (2).LDR---中序遍历

- 若二叉树为空，则空操作；否则：
  1. 中序遍历左子树
  2. 访问根节点
  3. 中序遍历右子树
  
- 中序遍历算法(递归实现)

  - ```c
    Status InOrderTraverse(BiTree T)
    {
        if(T == NULL)
            return OK;//空二叉树
        InOrderTraverse(T->lchild);//递归遍历左子树
        visit(T);//访问根节点，可以是输出或其他操作
        InOrderTraverse(T->rchild);//递归遍历右子树
    }
    ```

- 中序遍历算法（非递归算法)

  - 基本思想：

    1. 建立一个栈
    2. 根结点进栈，遍历左子树
    3. 根结点出栈，输出根结点，遍历右子树

  - ```c
    Status InorderTraverse(BiTree T)
    {
        BiTree p,q;
        InitStack(S);
        p=T;//p指向根结点
        while(p || !StackEmpty(S)) //树不为空，或栈不为空，终止条件为树和栈都空
        {
            if(p)//根结点不为空
            {
                Push(S,p);//根结点入栈
                p=p->lchild;//指针指向左子树根结点，开始遍历左子树
            }
            else//根结点为空
            {
                Pop(S,q);//根结点出栈
                visit(q);//访问根结点
                p=q->rchild;//指针指向右子树根结点
            }
        }
        return OK;
    }
    ```

#### (3).LRD---后序遍历

- 若二叉树为空，则空操作；否则：
  1. 后序遍历左子树
  2. 后序遍历右子树
  3. 访问根节点
  
- 后序遍历算法(递归实现)

  - ```c
    Status PostOrderTraverse(BiTree T)
    {
        if(T == NULL)
            return OK;//空二叉树
        PostOrderTraverse(T->lchild);//递归遍历左子树
        PostOrderTraverse(T->rchild);//递归遍历右子树
        visit(T);//访问根节点，可以是输出或其他操作
    }
    ```

#### (4).层次遍历

- 对于一棵二叉树，从根节点开始，从上到下，从左到右的顺序访问每一个结点，且每个结点仅访问一次

- 算法设计思路：

  1. 将根结点入队
  2. 队不空时循环：从队列中出列一个结点*p，访问它：
     1. 若它有左孩子结点，将左孩子结点入队
     2. 若它有右孩子结点，将右孩子入队

- ```c
  //队列类型定义
  typedef struct
  {
      BTNode data[MAXSIZE];
      int front,rear;
  }SqQueue;
  //层次遍历算法
  void LevelOrder(BTNode *b)
  {
      BTNode *p;
      SqQueue *b;
      InitQueue(qu);//初始化队列
      enQueue(qu,b);//根结点指针入队
      while(!QueueEmpty(qu))
      {
          deQueue(qu,p);//根结点出队
          visit(p);
          if(p->lchild != NULL)
              enQueue(qu,p->lchild);//有左孩子时将其入队
          if(p->rchild != NULL)
              enQueue(qu,p->rchild);//有右孩子时将其入队
      }
  }
  ```

### 5.二叉树的建立（按先序序列建立）

- 步骤：

  1. 键盘输入二叉树的结点信息，建立二叉树的存储结构
  2. 在建立二叉树的过程中按照二叉树先序的方式建立

- ```c
  Status CreateBiTree(BiTree &T)
  {
      scanf(&ch);
      if(ch == "#")
      {
          T=NULL;
      }
      else
      {
          T=(BiTNode*)malloc(sizeof(BiTNode));
          if(!T)
              exit(OVERFLOW);
          T->data=ch;
          CreateBiTree(T->lchild);//创建左子树
          CreateBiTree(T->rchild);//创建右子树
      }
      return OK;
  }
  ```

### 6.复制二叉树

- 如果是空树，递归结束；否则：

  - 申请新结点空间
  - 复制根结点
  - 递归复制左子树
  - 递归复制右子树

- ```c
  int Copy(BiTree T,BiTree &NewT)
  {
      if(T == NULL)
      {
          NewT=NULL;
          return 0;
      }
      else
      {
          NewT=(BiTNode*)malloc(sizeof(BiTNode));
          NewT->data=T->data;
          Copy(T->lchild,NewT->lchild);
          Copy(T->rchild,NewT->rchild);
      }
      return OK;
  }
  ```

### 7.计算二叉树的深度

- 算法思想：

  - 如果是空树，则深度为零
  - 否则，递归计算左子树的深度m，递归计算右子树的深度记为n，二叉树的深度则为m与n的较大值加一

- ```c
  int Depth(BiTree T)
  {
      if(T == NULL)
          return 0;
      m=Depth(T->lchild);//遍历左子树
      n=Depth(T->rchild);//遍历右子树
      if(m>n)
          return m+1;
      return n+1;
  }
  ```

### 8.计算二叉树结点总数

- 算法思想：

  - 如果是空树，则结点个数为零
  - 否则，结点个数为：左子树结点个数+右子树结点个数+1

- ```c
  int NodeCount(BiTree T)
  {
      if(T == NULL)
          return 0;
      return NodeCount(T->lchild)+NodeCount(T->rchild)+1;//加一加的是作为当前根结点的结点
  }
  ```

### 9.计算二叉树叶子结点总数

- 算法思想：

  - 如果是空树，则叶子结点个数为0
  - 否则，叶子结点总数为：左子树叶子结点个数+右子树叶子结点个数

- ```c
  int LeafCount(BiTree T)
  {
      if(T == NULL)
          return 0;
      if(T->lchild==NULL && T->rchild==NULL)
          return 1;//是叶子节点
      return LeafCount(T->lchild)+LeafCount(T->rchild);//不是叶子节点，则分别统计左右子树叶子结点个数
  }
  ```

### 10.根据遍历序列确定二叉树

- 若二叉树中各结点的值均不相同，则二叉树结点的先序序列、中序序列和后序序列都是唯一的。由二叉树的先序序列和中序序列，或由二叉树的后序序列和中序序列可以唯一确定一棵二叉树（但由先序序列和后序序列不可以）
  1. 先序和中序
     - 由先序确定根，由中序确定左右子树
  2. 后序和中序
     - 由后序确定根，由中序确定左右子树
     - 后序遍历，根结点必在后序序列尾部

### 11.线索二叉树

- 为什么要研究线索二叉树？

  - 当使用二叉链表作为二叉树的存储结构时，可以很方便地找到某个结点的左右孩子；但一般情况下，无法直接找到该结点在某种遍历序列中的前驱和后继结点

- 如何寻找特定遍历序列中二叉树结点的前驱和后继？

  - 解决方法：
    1. 通过遍历寻找（费时间）
    2. 再增设前驱、后继指针域（费空间）（增加了存储负担）
    3. 利用二叉链表中的空指针域：
       - 如果某个结点左孩子为空，则将空的左孩子域改为指向其前驱；
       - 如果某个结点右孩子为空，则将空的右孩子域改为指向其后继；
       - 注：这种改变指向的指针称为“线索”，这种加了线索的二叉树称为**线索二叉树**，对二叉树某种遍历次序使其变为线索二叉树的过程叫**线索化**
       - 为区分lchild和rchild 指针到底是指向孩子的指针，还是指向前驱和后继的指针，对二叉链表中每个结点增设两个标志域ltag和rtag，并约定：
         - ltag=0：lchild指向该结点的左孩子
         - ltag=1：lchild指向该结点的前驱
         - rtag=0：rchild指向该结点的右孩子
         - rtag=1：rhild指向该结点的后继

- 线索二叉树结点结构：

  - ```c
    typedef struct BiThrNode
    {
        int data;
        int ltag,rtag;
        struct BiThrNode *lchild,*rchild;
    }BiThrNode,*BiThrTree;
    ```

  - 为避免悬空态，增设了一个头结点

    - ltag=0，lchild指向根结点
    - rtag=1，rchild指向遍历序列的最后一个结点
    - 遍历序列中第一个结点的lc域和最后一个结点的rc域都指向头结点

## （六）树和森林

### 1.树的存储结构

1. 双亲表示法

   - 实现：

     - 定义数组，存放树的结点，每个结点含两个域：
       - 数据域：存放结点本身信息
       - 双亲域：指示本结点的双亲结点在数组中的位置

   - 特点：找双亲容易，找孩子难

   - 结点结构类型：

     - ```c
       typedef struct PTNode
       {
           TElemType data;
           int parent;//双亲位置域（数组下标）
       }PTNode;
       ```

   - 树结构：

     - ```c
       #define MAX_TREE_SIZE 100
       typedef struct
       {
           PTNode nodes[MAX_TREE_SIZE];
           int r,n;//根结点位置，结点个数
       }PTree;
       ```

2. 孩子链表

   - 把每个结点的孩子结点排列起来，看成一共线性表，用单链表存储，则n个结点有n个孩子链表（叶子的孩子链表为空表），而n个头指针又组成一共线性表，用顺序表（含n个元素的结构数组）存储

   - 特点：找孩子容易，找双亲难

   - 孩子结点结构：

     - ```c
       typedef struct CTNode
       {
           int child;
           struct CTNode *next;
       }*ChildPtr;
       ```

   - 双亲结点结构：

     - ```c
       typedef struct
       {
           TElemType data;
           ChildPtr firstchild;//孩子链表头指针
       }CTBox;
       ```

   - 树结构：

     - ```c
       typedef struct
       {
           CTBox nodes[MAX_TREE_SIZE];
           int n,r;结点数和根结点的位置
       }CTree;
       ```

3. 孩子兄弟表示法

   - 又叫二叉树表示法，二叉链表表示法

   - 实现：用二叉链表作为树的结构，链表中每个结点的两个指针域分别指向其第一个孩子结点和下一个兄弟结点

   - 结构：

     - ```c
       typedef struct CSNode
       {
           ElemType data;
           struct CSNode *firstchild,*nextsibling;
       }CSNode,*CSTree;
       ```

### 2. 树和森林的转换

- 将树转化为二叉树进行处理，利用二叉树的算法实现对树的操作

- 由于树和二叉树都可以用二叉链表作存储结构，则以二叉链表作媒介则可以导出树与二叉树之间的对应关系

- 给定一棵树，可以找到唯一的一棵二叉树与之对应

#### （1）.将树转换成二叉树：

- 兄弟相连留长子
      1. 加线：在兄弟之间加一连线
      2. 抹线：对每个结点，除了其左孩子外，去除与其余孩子的关系
      3. 旋转：以树的根结点为轴心，将整棵树顺时针旋转45°


#### （2）.将二叉树转换成树：

- 左孩右右连双亲，去掉原来右孩线
    1. 加线：若p结点是双亲的左孩子，则将p的右孩子，右孩子的右孩子......沿分支找到所有右孩子，都与p的双亲用线连起来
    1. 抹线：抹掉原二叉树中双亲与右孩子之间的连线
    1. 调整：将结点按层次排列，形成树结构


#### （3）.森林转换成二叉树：

- 树变二叉根相连
  1. 将各棵树分别转换成二叉树
  2. 将每棵树的根结点用线相连
  3. 以第一棵树根结点作为二叉树的根，再以根结点为轴心，顺时针旋转，构成二叉树型结构

#### （4）.二叉树转换成森林：

- 去掉全部右孩线，孤立二叉再还原
  1. 抹线：将二叉树中根结点与右孩子的连线，及沿右分支搜索到的所有右孩子间的连线全部抹掉，使之变成孤立的二叉树
  2. 还原：将孤立的二叉树还原成树

### 3. 树和森林的遍历

#### （1）.树的遍历（三种方式）

##### a.先根遍历

- 若树不为空，则先访问根结点，然后依次先根遍历各棵子树

##### b.后根遍历

- 若树不为空，则先依次后根遍历各棵子树，然后访问根结点

##### c.层次根遍历

- 若树不为空，则自上而下自左至右访问树中每个结点

#### （2）.森林的遍历

- 将森林看成三部分构成：

  1. 森林中的第一棵树的根结点
  2. 森林中第一棵树的子森林
  3. 森林中其他树的构成的森林

##### a.先序遍历：

  - 若树不为空，则：
    1. 访问森林中第一棵树的根结点
    2. 先序遍历森林中第一棵树的子树森林
    3. 先序遍历森林中（除第一棵树之外），其余树构成的森林
  - 即：依次从左到右对森林中每一棵树进行先根遍历

##### b.中序遍历：

- 若树不为空，则：
  1. 中序遍历森林中第一棵树的子树森林
  2. 访问森林中第一棵树的根结点
  3. 中序遍历森林中（除第一棵树之外），其余树构成的森林
  - 即：依次从左到右对森林中每一棵树进行后根遍历

## （七）哈夫曼树及其应用

### 1.哈夫曼树的基本概念

- 路径：从树中一个结点到另一个结点之间的分支构成这两个结点间的路径
- 结点的路径长度：两结点间路径上的分支数
- 树的路径长度：从树根到每一个结点的路径长度之和，记作：TL
  - 结点数目相同的二叉树中，完全二叉树是路径长度最短的二叉树
- 权：将树中结点赋给一个有着某种含义的值，这个数值称为该结点的权
- 结点的带权路径长度：从根结点到该结点之间的路径长度与该结点的权的乘积
- 树的带权结点路径长度：树中所有叶子结点的带权路径长度之和，记作WPL
- **哈夫曼树**：
  - 最优树：带权路径长度（WPL)最短的树
  - 最优二叉树：带权路径长度（WPL)最短的二叉树
  - 特点：
    1. 满二叉树不一定是哈夫曼树
    2. 哈夫曼树中权越大的叶子离根越近
    3. 具有相同带权结点的哈夫曼树不唯一

### 2.哈夫曼树的构造算法

- 贪心算法：构造哈夫曼树时首先选择权值最小的叶子结点

- 哈夫曼算法：

  1. 根据n个给定的权值构成n棵二叉树的森林，森林中的每棵树都只有一个对应的带权根结点（构造森林全是根）
  2. 在F中选取两棵根结点的权值最小的树作为左右子树，构建一棵新的二叉树，且设置新的二叉树的根结点的权值为其左右子树上根结点的权值之和（选用两小造新树）
  3. 在森林中删除这两棵树，同时将新得到的树加入森林中（删除两小添新树）
  4. 重复2、3，直到森林中只有一棵树，这棵树即为哈夫曼树（重复二三剩单树）

- 口诀：

  1. 构造森林全是根
  2. 选用两小造新树
  3. 删除两小添新树
  4. 重复二三剩单树

- 特点：

  1. 哈夫曼树的结点的度为0或2，没有度为1的结点
  2. 包含n个叶子结点的哈夫曼树中共有2n-1个结点（包含n棵树的森林要经过n-1次合并才能形成哈夫曼树，共产生n-1个结点）

- 算法实现：

  - 采用顺序存储结构（一维数组）

  - 结点类型定义：

    - ```c
      typedef struct
      {
          int weight;//权重
          int parent,lch,rch;//双亲、左孩子、右孩子结点下标
      }HTNode,*HuffmanTree;
      ```

  - 算法步骤：

    1. 初始化HT[1......2n-1]：lch=rch=parent=0
    2. 输入初始n个叶子结点：置于[1......n]的weight值
    3. 进行以下n-1次合并，依次产生n-1个结点HT[i],i=n+1,...,2n-1:
       - 在HT[i,...,i-1]中挑选两个违背选过（parent==0)的weight最小的两个结点HT[s1],HT[s2],s1,s2为两个最小结点下标
       - 修改HT[s1]和HT[s2]的的parent值：HT[s1].parent=i;HT[s2].parent=i;
       - 修改新产生的HT[i]:
         - HT[i].weight=HT[s1].weight+HT[s2].weight;
         - HT[i].lch=s1;HT[i].rch=s2;
  
  - 算法实现：
  
    - ```c
      void CreatHuffmanTree(HuffmanTree HT,int n)//初始化
      {
          if(n <= 1)
              return;
          m=2*n-1;//数组共2n-1个元素
          HT=(HTNode*)malloc((m+1)*sizeof(HTNode));//0号元素不用
          for(i=1;i<=m;++i)
          {
              HT[i].lch=0;
              HT[i].rch=0;
              HT[i].parent=0;
          }
          for(i=1;i<=n;++i)
              ;//输入前n个元素的weight值，HT[i].weight
          Select(HT,i-1,s1,s2);//写一个函数，实现：在HT[k](1<=k<=i-1)中选择两个其双亲域为0，且权值最小的结点，并返回它们在HT中的序号s1和s2
          HT[s1].parent=i;
          HT[s2].parent=i;//表示从F中删除s1和s2，其双亲域不为0了
          HT[i].lch=s1;HT[i].rch=s2;//s1和s2分别作为i的左右孩子
          HT[i].weight=HT[s1].weight+HT[s2].weight;//i的权值为左右孩子权值之和   
      }
      ```
  

### 3.哈夫曼编码

#### （1）.哈夫曼编码思想

##### 哈夫曼编码

1. 统计字符集中每个字符在电文中出现的平均概率（概率越大，要求编码越短）
2. 利用哈夫曼树的特点：权越大的叶子离根越近；将每个字符的概率值作为权值，构造哈夫曼树。则概率越大的结点，路径越短
3. 在哈夫曼树上标0或1：
   1. 结点的左分支标0，右分支标1
   2. 把从根到每个叶子上的路径上的标号连接起来，作为该叶子结点代表的字符编码

##### 问题1：为什么哈夫曼编码能够保证是前缀编码？

- 因为没有一片树叶是另一片树叶的祖先，所以每个叶子结点的编码就不可能是其他叶子结点编码的前缀

##### 问题2：为什么哈夫曼编码能够保证字符编码总长度最短？

因为哈夫曼树的带权路径长度最短，故字符编码长度最短

##### 性质：

1. 哈夫曼编码是前缀码
2. 哈夫曼编码是最优前缀码

#### （2）.哈夫曼编码的算法实现（？？？较复杂，未理清思路）

- ```c
  void CreatHuffmanCode(HuffmanTree HT,HuffmanCode &HC,int n)
  {
      //从叶子到根逆向求每个字符的哈夫曼编码，存储在编码表HC中
      HC=(char*)malloc((n+1)*sizeof(char));//分配n个字符编码的头指针矢量
      cd=(char*)malloc(n*sizeof(char));//分配临时存放编码的动态数组空间
      cd[n-1]='\0';//编码结束符
      for(i=1;i<=n;++i)//逐个字符求哈夫曼编码
      {
          start=n-1；
          c=i;
          f=HT[i].parent;
          while(f!=0)//从叶子结点开始向上回溯，直到根结点
          {
              --start;//回溯一次start指向前一个位置
              if(HT[f].lchild==c)
                  cd[start]='0';//结点c是f的左孩子，则生成代码0
              if(HT[f].rchild==c)
                  cd[start]='1';//结点c是f的右孩子，则生成代码1
              c=f;
              f=HT[f].parent;//继续向上回溯
          }
          HT[i]=(char*)malloc((n-start)*sizeof(char));//为第i个字符串编码分配空间
          strcpy(HC[i],&cd[start]);//将求的的编码从临时空间cd复制到HC的当前行中
      }
      free(cd);//释放临时空间
  }
  ```

#### （3）.文件的编码和译码

##### a.编码

1. 输入各字符及其权值
2. 构造哈夫曼树HT[i]
3. 构造哈夫曼编码HC[i]
4. 查HC[i],得到个字符的哈夫曼编码

##### b.译码

1. 构造哈夫曼树HT[i]
2. 依次读入二进制码
3. 读入0，则走向左孩子；读入1，则走向右孩子
4. 一旦到达某叶子，即可译出字符
5. 然后再从根出发继续译码，直到结束

- 存在问题：哈夫曼树不唯一，编码也不唯一，译码同样不唯一，是否还要约定更详细的构造哈夫曼树的规则
  - 例如：选用两小造新树时，是否约定更小的在左边；两小相同时，哪一个在左哪一个在右

# 六.图

## （一）.图的定义和基本术语

- 图：G=(V，E)			Graph=（Vertex，Edge）
  - V：顶点（数据元素）的有穷非空集合
  - E：边的有穷集合
- 无向图：每条边都是有方向的
- 有向图：每条边都是有方向的
- 完全图：任意两个点都有一条边相连

## （二）.案例引入

## （三）.图的类型定义

## （四）.图的存储结构

## （五）.图的遍历

## （六）.图的应用

## （七）.案例分析与实现

# 七.查找

## （一）查找的概念

- 问题：在哪里找？
  - 查找表：查找表是由同一类型的数据元素（或记录）构成的集合。由于集合中的数据元素之间存在松散的关系，因此查找表是一种应用灵便的结构
- 问题：什么查找？
  - 根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素（或记录）
    - 关键字：用来标识一个数据元素（或记录）的某个数据项的值
      - 主关键字：可以唯一标识一个记录的关键字
      - 次关键字：用于识别若干记录的关键字是次关键字
- 问题：成功与否？
  - 若查找表中存在这样一个记录，则“查找成功”
    - 查找成功则给出整个记录的信息，或指示该记录在查找表中的位置
  - 否则“查找不成功”
    - 查找结果给出“空记录”或“空指针”
- 问题：查找目的是什么？
  - 查询某个特定的数据元素是否在查找表中
  - 检索某个特点是数据元素的各种属性
  - 在查找表中插入一个数据元素
  - 删除查找表中某个数据元素
- 问题：查找表怎么分类？
  - 查找表分为两类：
    - 静态查找表：
      - 仅作查询（检索）操作的查找表
    - 动态查找表：
      - 作插入删除操作的查找表
      - 有时查询后还需要将查询结果“不在查找表中”的数据元素插入到查找表中；或者，从查找表中删除其查询结果为“在查找表中”的数据元素
- 问题：如何评价查找算法？
  - 查找算法的评价指标：
    - 关键字的平均比较次数，也成平均查找长度，ASL
- 查找过程中我们要研究什么？
  - 查找方法取决与查找表的结构，即表中数据元素是依何种关系组织在一切的
  - 为提高查找效率，一个办法就是在构造查找表时，在集合中的数据元素人为地加上某种确定的约束关系

## （二）线性表的查找

### 1.顺序查找（线性查找）

- 顺序查找：在顺序表ST中查找值为key的数据元素，从最后一个元素开始比较

- 应用范围：

  - 顺序表或线性链表标识的静态查找表
  - 表内元素无序

- 顺序表的标识：

  - 数据元素类型定义：

    - ```c
      typedef struct
      {
          KeyType key;//关键字域
          ...//其他域
      }ElemType;
      typedef struct
      {
          ElemType *R;//表的基地址
          int length;//表长
      }SStable;//Sequential Search Table
      SStable ST;//定义顺序查找表
      ```

#### 算法1：

  - 类C代码：

    - 原版：

      - ```c
        //若查找成功，则返回其位置信息；否则返回0
        int Search_Seq(SStable ST,KeyType key)
        {
            for(i = ST.length;i >= 1;--i)
                if(ST.R[i].key == key)
                    return i;
            return 0;
        }
        ```

    - 其他写法：

      - ```c
        int Search_Seq(SStable ST,KeyType key)
        {
            for(i = ST.length; ST.R[i].key == key; --i)
                if(i <= 0)
                    break;
            if(i>0)
            	return i;
            return 0;
        }
        ```

      - ```c
        int Search_Seq(SStable ST,KeyType key)
        {
            for(i = ST.length; ST.R[i].key == key && i>0; --i);
            if(i>0)
            	return i;
            return 0;
        }
        ```

  - C语言实现：

    - ```c
      ```

#### 算法2：增加监视哨的顺序查找

  - 改进：把待查关键字key存入表头（“哨兵”，“监视哨”），从后往前逐个比较，可免去查好过程中每一步都要检测是否查找完毕，加快速度

  - 当ST.length较大时，此改进能使一次查找所需的平均时间几乎减少一半

    - 类C代码：

      - ```c
        int Search_Seq(SStable ST,KeyType key)
        {
            ST.R[0].key = key;
            for(i = ST.length; ST.R[i].key == key; --i);//i=0时一定会等于key,结束循环
            return i;
        }
        ```

    - C语言实现：
    
      - ```c
        ```
    
  - 时间效率分析：

    - 比较次数与key 的位置有关：
        - 查找第i个元素，需要比较n-i-1次
        - 查找失败，需要比较n+1次

    - 时间复杂度：O（n）
        - （n+1）/2

    - 空间复杂度：O（1）

  - 讨论：

    1. 记录的查找概率不相等时如何提高查找效率？
       - 查找表存储记录原则：按查找概率高低存储
           - 查找概率越高，比较次数越少
           - 查找概率越低，比较次数越多

    2. 记录的查找概率无法测定时如何提高查找效率？
       - 按查找概率动态调整记录规则
         - 在每个记录中设一个访问频度域
         - 始终记录按非递增有序的次序排列
         - 每次查找后将刚查找到的记录之间移至表头

- 顺序查找的特点：
  - 优点：算法简单，逻辑粗徐无要求，且不同存储结构均适用
  - 缺点：ASL太长，时间效率太低

### 2.折半查找（二分查找或对分查找）

- 折半查找：每次将待查记录所在区间缩小一半

- 查找过程：

  - low
  - high
  - mid = (low + high) / 2
  - key < mid 则 high = mid  - 1
  - key > mid 则 low = mid + 1
  - key == mid 找到
  - high < low 结束，找不到

- 折半查找算法（非递归算法）

  - 类C代码：

    - ```c
      //设表长为n，low、high和mid分别指向待查元素所在区间的上界。下界和中点，key为给定的要查找的值
      //初始时，令low = 1，high = n，mid = (low + high) / 2
      //让key与mid指向的记录比较：
      //key == R[mid].key，查找成功；
      //key < R[mid].key, high = mid - 1
      //key > R[mid].key, low = mid + 1
      //重复上述操作，直到high < low 结束，找不到
      int Search_Bin(SSTable ST, KeyType key)
      {
          low = 1;high = ST.length;
          while(low <=high)
          {
              mid = (low + high) / 2;
              if(key == ST.R[mid].key)
                  return key;
              if(key < ST.R[mid].key)
              {
                  high = mid - 1;//key在mid左边，在前半区查找
              }
              else
              {
                  low = mid + 1;
              }
          }
          return 0;
      }
      ```

  - C语言实现：

    - ```c
      
      ```

- 折半查找算法（递归算法）

  - 类C代码：

    - ```c
      int Search_Bin(SSTable ST, KeyType key, int low, int high)
      {
          if(low > high)
              return 0;
          mid = (low + high) / 2;
          if(key == ST.R[mid].key)
              return key;
          if(key < ST.R[mid].key)
          {
              high = mid - 1;
              Search_Bin(ST, key, low, high);
          }
          else
          {
              low = mid + 1;
              Search_Bin(ST, key, low, high); 
          }
      }
      ```

  - C语言实现：

    - ```c
      ```

- 折半查找算法分析：

  - 比较次数 <= 树的深度（logn - 1）

- 折半查找特点：

  - 优点：效率比顺序查找高
  - 缺点：只适用与有序表，且限于顺序存储结构（对线性链表无效）

### 3.分块查找

- 条件：
  - 将表分成几块，且表有序、或分块有序，若i < j，则第 j 块中所有记录的关键字均大于第 i 块中最大的关键字
  - 建立索引表（每个结点含有最大关键字和指向本块第一个结点的指针，且按关键字有序
- 查找过程：
  - 先确定待查记录所在块（顺序查找），然后再在块内查找（顺序查找）
- 分块查找算法分析及比较
- 分块查找特点：
  - 优点：插入和删除比较容易，无需进行大量移动
  - 缺点：要增加一个索引表的储存空间并对初始索引表进行排序算法
  - 适用情况：如果线性表既要快速查找又经常动态变化，则可采用分块查找

### 4.查找方式比较

|          |     顺序查找     | 折半查找 |     分块查找     |
| -------- | :--------------: | :------: | :--------------: |
| ASL      |       最大       |   最小   |       中间       |
| 表结构   |  有序表、无序表  |  有序表  |     分块有序     |
| 存储结构 | 顺序表、线性链表 |  顺序表  | 顺序表，线性链表 |

## （三）树表的查找

- 当表中插入、删除操作频繁时，为维护表的有序性，需要移动表中很多记录，改用动态查找表 --- 几种特殊树，表结构在查找过程中动态产生，对于指定key，若表中存在，则成功返回；否则，插入关键字d等于key的记录

  - 二叉排序树

  - 平衡二叉树

  - 红黑树

  - B-树

  - B+树

  - 键树

### 1.二叉排序树

  - 又称二叉搜索树、二叉查找树

  - 定义：

    - 二叉排序树或是空树，或是满足以下性质的二叉树
      - 若其左子树非空，则左子树上所有结点的值均小于根结点的值
      - 若其右子树非空，则右子树上所有结点的值均大于等于根结点的值
      - 其左右子树本身又各是一棵二叉排序树

  - 二叉排序树性质：

    - 中序遍历非空的二叉排序树所得到的数据元素序列是一个按照关键字排序的递增有序序列
#### 二叉排序树的操作 --- 查找

- 二叉排序树的查找：

  - 若查找的关键字等于根结点，成功
  - 否则
    - 若小于根结点，查其左子树
    - 若大于根结点，查其右子树

  - 在左右子树上的操作类似

- 二叉排序树的存储结构

  - ```c
    typedef struct
    {
        KeyType key;//关键字项
        InfoType otherinfo;//其他数据域
    }ElemType;
    typedef struct
    {
        ElemType data;//数据域
        struct BSTNode *lchild,*rchild;//左右孩子指针
    }BSTNode,*BSTree;
    BSTree T;//定义二叉排序树
    ```

- 算法：二叉排序树的递归查找

  - 算法思想：

    - 若二叉排序树为空，则查找失败，返回空指针
    - 若二叉排序树非空，将给定值key与根结点的关键字`T->data.key`进行比较：
      - 若`key == T->data.key`，则查找成功，返回根结点地址
      - 若`key < T->data.key`，则进一步查找左子树
      - 若`key > T->data.key`，则进一步查找右子树

  - 类C代码：

    - ```c
      BSTree SearchBST(BSTree T, KeyType key)
      {
          if(!T || key == T->data.key)
              return T;
          if(key < T->data.key)
              return SearchBST(T->lchild,key);
          return SearchBST(T->rchild,key);
      }
      ```

- 二叉排序树查找算法分析

- 问题：如何提高形态不均衡的二叉排序树的查找效率？

  - 做平衡化处理，尽量让二叉树的形状均衡

#### 二叉排序树的操作 --- 插入

- 二叉排序树的插入：
  - 若二叉排序树为空，则插入结点作为根结点插入到空树中
  - 否则，继续在其左右子树上查找
    - 树中已有，不再插入
    - 树中没有
      - 查找直至某个叶子结点的左子树或右子树为空为止，则插入结点应为该叶子结点的左孩子或右孩子


#### 二叉排序树的操作 --- 生成

- 二叉排序树的生成：
  - 从空树出发，经过一系列的查找、插入操作之后，可生成一棵二叉排序树

#### 二叉排序树的操作 --- 删除

- 从二叉排序树中删除一个结点，不能把以该结点为根的子树都删去，只能删掉该结点，并且还应保证删除后的二叉树仍然满足二叉排序树的性质不变。由于中序遍历二叉排序树可以得到一个递增有序的序列，那么，在二叉排序树中删去一个结点相当于删去有序序列中的一个结点
  - 将因删除结点而断开的二叉链表重新链接起来
  - 防止重新链接后树的高度增加
- 二叉排序树的删除
  - 若被删除的结点是叶子结点：之间删去该结点
  - 若被删除的结点只有左子树或只有右子树，用其左子树或右子树替换它
  - 若被删除的结点既有左子树，又有右子树
    - 以其中序前驱值替换之，然后删除该前驱结点，前驱是左子树中最大的结点
    - 也可以用其后继替换之，然后删除该后继结点，后继是右子树中最小结点

### 2.平衡二叉树-

- 平衡二叉树的定义：
  - 平衡二叉树（balanced binary tree)，又称AVL树（Adelson - Velskii and Landis）
  - 一棵平衡二叉树或是空树，或是具有以下性质的二叉排序树
    - 左子树与右子树的高度差的绝对值小于等于1
    - 左子树和右子树也是平衡二叉排序树
- 为了方便起见，给每个结点附加一个数字，给出该结点左子树与右子树的高度差。这个数字称为结点的平衡因子（BF）
  - 平衡因子 = 结点左子树的高度 - 结点右子树的高度差
  - 根据平衡二叉树的定义，平衡二叉树上所有结点的平衡因子只能是-1 、 0 、1
- 失衡二叉树的分析与调整
  - 当我们在平衡二叉排序树上插入一个结点时，有可能导致失衡，即出现平衡因子绝对值大于1的结点，如：2 、 -2。如果在一棵AVL树中插入一个新结点后造成失衡，则必须重新调整树的结构，使之恢复平衡
  - 四种类型：
    - LL型：
      - 调整过程：
        - B结点带着左子树一起上升
        - A结点成为B的右孩子
        - 原来B结点的右子树作为A的左子树
    - RR型：
      - 调整过程：
        - B结点带着右子树一起上升
        - A结点成为B的左孩子
        - 原来B结点的左子树作为A的右子树
    - LR型：
      - 调整过程：
        - C结点穿过A、B结点上升
        - B结点成为C的左孩子
        - A结点成为C的右孩子
        - 原来C结点的左子树作为B的右子树
        - 原来C结点的右子树作为A的A子树
    - RL型：
      - 调整过程：
  - 调整原则：
    - 降低高度
    - 保持二叉排序树的性质

## （四）哈希表的查找

### 1.散列表的基本概念：

- 基本思想：
  - 记录的存储位置与关键字之间存在对应关系（对应关系 --- hash函数）
    - `Loc( i ) = H( keyi )`，hash函数；Hash哈希：翻译为：散列、杂凑

- 如何查找：
  - 根据散列函数`H(key) = k`
    - 查找`key = 9`，则访问`H(9) = 9`号地址，若内容为9则成功
    - 若查不到，则返回一个特殊值，如空指针或空记录
  - 优点：查找效率高
  - 缺点：空间效率低
- 散列表的若干术语
  - 散列方法（杂凑法）：
    - 选取某个函数，依该函数按关键字计算元素的储存位置，并按此存放；
    - 查找时，由同一个函数对给定值 k 计算地址，将 k 与地址单元中元素关键码进行对比，确定查找是否成功
  - 散列函数（杂凑函数）：
    - 散列方法中使用的转换函数
    - `H(key) = k`
  - 散列表（杂凑表）：
    - 按上述思想构造的表
  - 冲突：
    - 不同的关键码映射到同一个散列地址
    - key1 != key2，但是H(key1) = H(key2)
  - 同义词：
    - 具有相同函数的多个关键字

### 2.散列函数的构造

- 在散列查找方法中，冲突是不可避免的，只能尽可能减少
- 使用散列表要解决好两个问题：
  1. 构造好的散列函数
     - 所选函数尽可能简单 ，以便提高转换速度
     - 所选函数对关键码计算出的地址，应在散列地址集中致均匀分布，以减少空间浪费
  2. 制定一个好的解决冲突的方案
     - 查找时，如果从散列函数计算出的地址中查不到关键码，则应当依照解决冲突的规则，有规律地查询其他相关单元
- 构造散列函数考虑的因素：
  - 执行速度（即计算散列函数所需的时间）
  - 关键字的长度
  - 散列表的长度
  - 关键字的分布情况
  - 查找频率
- 根据元素集合的特性构造
  - 要求1：n个数据原仅占用n个地址，虽然散列查找是以空间换时间，但仍希望散列的地址空间尽量小
  - 要求2：无论用什么方法储存，目的都是尽量均匀地存放元素，以避免冲突
    - 直接定址法
      - `Hash(key) = a * key + b` `(a、b为常数)`
      - 优点：以关键码key的某个线性函数值为散列地址，不会产生冲突
      - 缺点：要占用连续地址空间，空间效率低
    - 数字分析法
    - 平方取中法
    - 折叠法
    - 除留余数法
      - `Hash(key) = key mod p` `(p是一个整数)`
      - 关键：如何选取合适的p?
      - 技巧：设表长为m，取p <= m且为质数
    - 随机数法
- 解决冲突的方法：
  - 开放定址法（开地址法）
    - 基本思想：有冲突时就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将数据元素存入
    - 例如：除留余数法 `Hi = (Hash(key) +di) mod m` `(p是一个整数)` `di为增量序列`
    - 常用方法：
      - 线性探测法：di 为1、2、...、m-1线性序列
        -  `Hi = (Hash(key) +di) mod m`  `(1 <= i < m)`
          - 其中：m为散列长度，di为增量序列1、2、...、m-1，且di = i
        - 一旦冲突，就找下一个地址，直到找到空地址存入
      - 二次探测法：di 为1^2、-1^2，2^2，-2^2，...，q^2 二次序列
        - 例：关键码集为{47，7，29，11，16，92，22，8，3}
          - 设：散列函数为 `Hash(key) = key mod 11`
            - `Hi = (Hash(key) +di) mod m`
            - 其中 m 为散列表长度，m 要求是某个`4k + 3 `的质数；di为1^2、-1^2，2^2，-2^2，...，q^2 二次序列
          - Hash(3) = 3，散列地址冲突，由`H1 = (Hash(3) + 1^2) mod 11 = 4`，仍然冲突
          - `H2 = (Hash(3) - 1^2) mod 11 = 2`，找到空的散列地址，存入
      - 伪随机探测法：di 为伪随机数序列
        - `Hi = (Hash(key) +di) mod m`
          - 其中 m 为散列表长度
          - di为伪随机数
  - 链地址法（拉链法）
    - 基本思想：相同散列地址的记录链成一个单链表，m 个散列地址就设 m 个单链表，然后用一个数组将 m 个单链表的表头指针储存起来，形成一个动态的结构
    - 链地址法建立散列表步骤：
      1. 取数据元素的关键字key，计算其散列表函数值（地址）。若该地址对应的链表为空，则该元素插入此链表；否则执行步骤2
      2. 根据选择的冲突处理方法，计算关键字 key 的下一个储存地址。若该地址对应的链表不为空，则利用链表的前插法或后插法将该元素插入此链表
    - 链地址法的优点：
      - 非同义词不会冲突，无聚集现象
      - 链表上的结点空间动态申请，更适合于表长不确定的情况
  - 再散列法（双散列函数法）
  - 建立一个公共溢出区
- 散列表查找性能分析
  - 使用平均查找长度ASL来衡量查找算法，ASL取决于：
    - 散列函数
    - 处理冲突的方法
    - 散列表的装填因子α（α = 表中填入的记录数 / 哈希表的长度）
      - α 越大，表中记录元素越多，说明表装的越满，发生冲突的可能性就越大，查找时比较次数就越多
      - ASL与装填因子 α 有关，既不是严格的O(1)，也不是O(n)
        - 拉链法：ASL ≈ 1 + α / 2
        - 线性探测法：ASL ≈ 1/2（1 + 1/（1 - α））
        - 随机探测法：ASL ≈ -1/α  * ln(1 - α )
  - 几点结论：
    - 散列表技术具有很好的平均性能，对于一些传统的技术
    - 链地址法由于开地址法
    - 除留余数法作散列函数优于其他类型函数

# 八.排序

## （一）排序概述

- 排序：将一组杂乱无章的数据按一定规律顺次排列起来，即，将无序序列排成一个有序序列（由小到大或由大到小）的运算
  - 如果参加排序的数据结点包含多个数据域，那么排序往往是针对其中某个域而言
  
- 排序方法分类：
  - 按数据存储介质：内部排序和外部排序
    - 内部排序：数据量不大，数据再内存，无需内外村交换数据
    - 外部排序：数据量较大，数据在外存（文件排序）
      - 外部排序时，要将数据分批调入内存来排序，中间结果还要及时放回外存，显然外部排序要复杂得多
  - 按比较器个数：串行排序和并行排序
    - 串行排序：单处理机（同一时刻比较一对元素）
    - 并行排序：多处理机（同一时刻比较多对元素）
  - 按主要操作：比较排序和基数排序
    - 比较排序：用比较的方法
      - 插入排序、交换排序、选择排序、归并排序
    - 基数排序：不比较元素的大小，仅仅根据元素本身的取值确定其有序位置
  - 按辅助空间：原地排序和非原地排序
    - 原地排序：辅助空间为O(1)	
      - （所占辅助存储空间与参加排序的数据量大小无关
    - 非原地排序：辅助空间用量超过O(1)的排序方法
  - 按稳定性：稳定排序和非稳定性排序
    - 稳定排序：能够使任何数值相等的元素，排序以后相对次序不变
      - 排序的稳定性只对结构类型数据排序有意义
      - 排序方式是否稳定，并不能衡量一个排序算法的优劣
    - 非稳定性排序：不是稳定排序的方法
  - 按自然性：自然排序和非自然排序
    - 自然排序：输入数据越有序，排序的速度越快的排序方法
    - 非自然排序：不是自然排序的方法
  - 按排序原则：
    - 插入排序：直接插入排序、折半插入排序、希尔排序
    - 交换排序：冒泡排序、快速排序
    - 选择排序：简单选择排序、堆排序
    - 归并排序：2-路归并排序
    - 基数排序
  - 按排序所需工作量：
    - 简单的排序方法：T(n) = O(n^2)
    - 基数排序：T(n) = O(d.n)
    - 先进的排序方法：T(n) = O(nlogn)
  
- 存储结构（记录序列以顺序表存储）

  - ```c
    #define MAXSIZE 20 //设记录不超过20个
    typedef int KeyType; //设关键字为整型
    typedef struct //定义每个记录（数据元素）的结构
    {
        KeyType key; //关键字
        InfoType otherinfo; //其他数据项
    }RedType;
    typedef struct //定义顺序表的结构
    {
        RedType r[MAXSIZE + 1]; //存储顺序表的向量 //r[0]一般作哨兵或缓冲区
        int length; //顺序表的长度
    }SqList;
    ```

## （二）插入排序

- 基本思想：

  - 每步将一个待排序的对象，按其关键码大小，插入到前面已经排好序的一组对象的适当位置上，直到对象全部插入为止
  - 即边插入边排序，保证子序列中随时都是排好序的

- 基本操作：

  - 有序插入
    - 在有序序列中插入一个元素，保持序列有序，有序长度不断增加
    - 起初`a[0]`是长度为1的子序列，然后，逐一将`a[1]`至`a[n-1]`插入到有序子序列中
      - 在插入`a[i]`前，数组a的前半段`(a[0]~a[i-1])`是有序段，后半段`(a[i]~a[n-1])`是停留于输入次序的无序段
      - 插入a[i]使`a[0]~a[i]`有序，也就是要为`a[i]`找到有序位置` j (0<=j<=i)`，将`a[i]`插入在`a[j]`的位置上

- 插入排序的种类：

  - 直接插入排序：

    - 顺序法定位插入位置

      - 不使用哨兵：
        - 复制插入元素`x = a[i];`
        - 记录后移，查找插入位置 `for(j = i - 1; j >= 0 && x < a[j] ;j--) a[j+1] = a[j];`
        - 插入到正确位置`a[j+1] = x;`
      - 使用哨兵;
        - 复制插入元素` L.r[0= L.r[i];`
        - 记录后移，查找插入位置 `for(j = i - 1; L.r[0].key < L.r[j].key ;j--) L.r[j+1] = L.r[j];`
        - 插入到正确位置`L.r[j+1] = L.r[0];`

    - 类C代码：

      - ```c
        void InserSort(SqList &L)
        {
            int i , j;
            for(i = 2; i <= L.length; i++)
            {
                if(L.r[i].key < L.r[i-1].key)
                {
                    L.r[0] = L.r[i];//复制为哨兵
                    for(j = i - 1; L.r[0].key < L.r[j].key ;j--) 
                        L.r[j+1] = L.r[j];
                }
                L.r[j+1] = L.r[0]; //插入到正确位置
            }
        }
        ```

    - C语言实现：

      - ```c
        ```

      - 

  - 二分插入排序：

    - 二分法定位插入位置

    - 类C代码：

      - ```c
        void BInsertSort(SqList &L)
        {
            for(i = 2; i <= L.length; i++) //依次插入第2~n个元素
            {
                L.r[0] = L.r[i]; //当前插入元素存到哨兵位置
                low = 1;
                high = i-1; //采用二分法查找插入位置
                while(low <= high)
                {
                    mid = (low + high) / 2;
                    if(L.r[0].key < L.r[mid].key)
                    {
                         high = mid -1;
                    }
                    else
                    {
                        low = mid +1;
                    } //循环结束，high + 1则为插入位置
                    for(j = i - 1; j >=high + 1; j--)
                        L.r[j+1] = L.r[j]; //移动元素
                }
            }
        }
        ```

    - C语言实现：

      - ```c
        ```

    - 折半插入排序算法分析：

      - 折半查找比顺序查找快，所以折半查找排序就平均性能来说比直接插入排序要快
      - 它所需要的关键码比较次数与待排序对象序列的初始无关，仅依赖与对象个数。在插入第 i 个对象时，需经过`logi + 1`次关键码比较，才能确定它应插入的位置
        - 当n较大时，总关键码比较次数比直接插入排序的最坏情况要好得多，但比其最好情况要差
        - 在对象的初始排列已经按关键码排好序或接近有序时，直接插入排序比折半查找执行的关键码比较次数要少
      - 折半查找排序的对象移动次数与直接插入排序相同，依赖与对象的初始排列
        - 减少了比较次数，但没有减少移动次数
        - 平均性能由于直接排序
          - 时间复杂度O(n^2)
          - 空间复杂度O(1)
          - 是一种稳定的排序方法

  - 希尔排序：

    - 特点：

      - 缩小增量
      - 多遍插入排序

    - 思考：直接插入排序在基本有序时，效率比较高；在待排序记录个数较少时，效率较高

    - 基本思想：

      - 先将整个待排记录序列分割成若干子序列，分别进行直接插入排序，待整个序列中的记录基本有序时，再对整个全体记录进行一次直接插入排序

    - 希尔排序特点：

      - 一次移动，移动位置较大，跳跃式地接近排序后的最终位置
      - 最后一个只需要少量移动
      - 增量移动必须时递减的，最后一个必须是1
      - 增量序列应该是互质的

    - 希尔排序算法（主程序）

      - 类C代码：

        - ```c
          void ShellSort(SqList &L, int dlta[], int t)
          {
              //按增量序列dlta[0...t-1]对顺序表L作希尔排序
              for(k = 0; k < t; ++k)
                  ShellInsert(L, dlta[k]); //一趟增量为dlta[k]的插入排序
          }
          ```

      - C语言实现：

        - ```c
          ```

    - 希尔排序算法（其中某一趟的排序操作）

      - 类C代码：

        - ```c
          void ShellInsert(SqList &L, int dk)
          {
              //对顺序表L进行一趟增量为dk的Shell排序，dk为步长因子
              for(i = dk + 1; i <= L.length; i++)
              {
                  if(r[i].key < r[i-dk].key)
                  {
                      r[0] = r[i];
                      for(j = i - dk; j > 0 && (r[0].key < r[j].key); j = j - dk)
                          r[j+dk] = r[j];
                      r[j+dk] = r[0];
                  }
              }
          }
          ```

      - C语言实现：

        - ```c
          
          ```

    - 希尔排序算法分析：

      - 希尔排序算法效率与增量序列的取值有关
      - Hibbard增量序列
        - Dk = 2^(k-1)  ---  相邻元素互质
        - 最坏情况：T = O(n^(3/2))
        - 猜想：Tavg = O(n^(5/4))
      - Sedgewicl增量序列
        - ...
        - 最坏情况：T = O(n^(4/3))
        - 猜想：Tavg = O(n^(7/6))
      - 希尔排序是一种不稳定的排序算法
      - 如何选择最佳d序列，目前尚未完全解决
      - 最后一个增量值必须为1，无除了1之外的公因子
      - 不宜再链式存储结构上实现

## （三）交换排序

- 基本思想：

  - 两两比较，如果发生逆序则交换，直到所有记录都排好序位置

- 常见的交换排序算法：

  - 冒泡排序：O(n^2)

  - 快速排序：O(nlogn)

### 1.冒泡排序：

  - 总结：n个记录，总共需要n-1趟；第m趟需要比较n-m趟

  - 冒泡排序算法：

    - 类C代码：

      - ```c
        void bubble_sort(SqList &L)
        {
            int m, i, j;
            RedType x; //交换时用于临时储存
            for(m = 1; m <= n-1; m++)
            {
                for(j = 1; j<= n-m; j++)
                {
                    if(L.r[j].key >L.r[j+1].key) //发生逆序
                    {
                        x = L.r[j];
                        L.r[j] = L.r[j+1];
                        L.r[j+1] = x;
                    }
                }
            }
        }
        ```

    - C语言实现：

      - ```c
        ```

  - 优点：每趟排序时，不仅能挤出一个最大值到最后面，还能同时部分理顺其他元素

  - 思考：如何提高效率？

    - 一旦某一趟比较时不出现记录交换，说明已经排好序了，就可以直接结束本算法

  - 改进的冒泡排序算法：

    - 类C代码：

      - ```c
        void bubble_sort(SqList &L)
        {
            int m, i, j;
            int flag = 1; //flag用于标记是否发生了交换
            RedType x; //交换时用于临时储存
            for(m = 1; m <= n-1 && flag == 1; m++)
            {
                flag = 0;
                for(j = 1; j<= n-m; j++)
                {
                    if(L.r[j].key >L.r[j+1].key) //发生逆序
                    {
                        flag = 1; //若发生了交换，则将flag置于1，下一趟排序算法继续；若本趟未交换，则结束排序
                        x = L.r[j];
                        L.r[j] = L.r[j+1];
                        L.r[j+1] = x;
                    }
                }
            }
        }
        ```

    - C语言实现：

      - ```c
        ```

  - 冒泡排序算法分析：

    - 最好情况：时间复杂度O(n)
    - 最坏情况：时间复杂度O(n^2)
    - 平均时间复杂度O(n^2)
    - 辅助空间S(n) = O(1)
    - 冒泡排序是稳定的

### 2.快速排序

- 改进的交换排序

- 基本思想：

  - 任取一个元素为中心（pivot：枢轴、中心点）
    - 枢轴、中间数：可以是第一个数、最后一个数、最中间一个数、任选一个数
  - 所有比他小的元素一律前放，比他大的元素一律后放，形成两个左右子表
  - 对各子表重新选择中心元素并依此规则调整（递归）
  - 直到每一个子表的元素只剩一个
  - 总结：通过一趟排序，将待排序记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，则可分别对这两部分进行排序，以达到整个序列有序

- 具体实现：

  - 选定一个中间数作为参考，所有元素与之比较，小的调到其左边，大的调到其右边

- 步骤：

  - 每一趟子表的形成是采用从两头向中间交替式逼近法
  - 由于每趟中对各子表的操作都相似，可采用递归算法

- 快速排序算法：

  - 类C代码：

    - ```c
      void main()
      {
          QSort(L, 1, L.length);
      }
      void QSort(SqList &L, int low, int high) //对顺序表L快速排序
      {
          if(low < high) //长度大于1
          {
              pivotloc = Partition(L, low, high); //将L.r[low...high]一分为二，pivotloc为枢轴元素排好序的位置
              QSort(L, low, pivotloc-1); 	//对低子表递归排序
              QSort(L, pivotloc+1, high); //对高子表递归排序
          }
      }
      int Partition(SqList &L, int low, int high)
      {
          L.r[0] = L.r[low];
          pivotkey = L.r[low].key;
          while(low < high)
          {
              while(low < high && L.r[high].key >= pivotkey)
                  high--;
              while(low < high && L.r[high].key <= pivotkey)
                  low++;
          }
          L.r[low] = L.r[0];
          return low;
      }
      ```

  - C语言实现：
  
    - ```c
      
      ```
  
- 快速排序算法分析：

  - 时间复杂度

    - 平均计算时间O(nlogn)
      - Qsort：O(logn)
      - Partiton：O(n)

    - 就平均时间而言：快速排序是我们所讨论的所有排序方法中最好的一个

  - 空间复杂度：
    - 快速排序不是原地排序，由于程序中使用了递归，需要递归调用栈的支持，而栈的长度取决于递归调用的深度
      - 在平均情况下：需要O(logn)的栈空间
      - 最坏情况下：栈空间可达O(n)

  - 稳定性：快速排序是一种不稳定的排序方法
  - 快速排序不适用于原本有序或基本有序的记录序列进行排序
  - 划分元素的选取是影响时间的关键
  - 输入数据次序越乱，所划分元素值的随机性越好，排序速度越快，快速排序不是自然排序方法
  - 改变划分元素的选取方法，至多只能改变算法平均情况下的时间性能，无法改变最坏情况下的时间性能。即最坏情况下，快速排序的时间复杂度总是O(n^2)


## （四）选择排序

### 1.简单选择排序

- 基本思想：

  - 在待排序的数据中选出最大（小）的元素放在最终位置

- 基本操作：

  - 首先通过 n-1 次关键字比较，从 n 个记录中找出关键字最小的记录，将他与第一个记录交换
  - 再通过 n-2 次比较，从剩余 n-1 个记录中找出关键字次小的记录，将它与第二个元素交换
  - 重复上述操作，共进行 n-1 趟排序后，排序结束

- 简单排序算法：

  - 类C代码：

    - ```c
      void SelectSort(SqList &K)
      {
          for(i = 1; i < L.length; i++)
          {
              k = i;
              for(j = i + 1; j <= L.length; j++)
              {
                  if(L.r[j].key < L.r[k].key)
                      k = j; //记录最小值位置
                  if(k != i)
                      //交换L.r[i]与L.r[k]
              }
          }
      }
      ```

  - C语言实现：

    - ```c
      ```

- 简单选择排序算法分析：

  - 时间复杂度：
    - 记录移动次数：
      - 最坏情况：0
      - 最坏情况：3(n-1)
    - 比较次数：无论待排序列处于什么状态，选择排序所需比较的次数都相同
      - n(n-1)/2
  - 稳定性：简单选择排序是不稳定排序

### 2.堆排序

- 堆的定义：

  - 若 n 个元素的序列{a1 a2 ... an}满足
    - ai <= a2i
    - ai <= a(2i+1)
      - 或
    - ai >= a2i
    - ai >= a(2i+1)
  - 则分别称该序列为 小根堆 和 大根堆

- 从堆的定义可以看出：

  - 堆实质是满足以下性质的完全二叉树：
    - 二叉树中任一非叶子结点均小于（大于）它的孩子结点

- 堆排序：

  - 若在输出堆顶的最小值（最大值）后，使得剩余 n-1 个元素的序列重新建成一个堆，则得到 n 个元素的次小值（次大值）...如此反复，便能得到一个有序序列，这个过程称为 堆排序

- 实现堆排序需要解决两个问题：

  - 如何由一个无序序列建成一个堆？

    - 显然：

      - 单结点的二叉树是堆；在完全二叉树中所有叶子结点（序号 i > n/2）为根的子树是堆。这样我们只需要依次将以序号 n/2，n/2-1，...，1 的结点为根子树均调整为堆即可

    - 从最后一个非叶子结点开始，依次向前调整：

      - 调整从第 n/2 个元素开始，将以该元素为根的二叉树调整为堆
      - 将以序号为 n/2-1 的结点为根的二叉树调整为堆
      - 将以序号为 n/2-2 的结点为根的二叉树调整为堆
      - 将以序号为 n/2-3 的结点为根的二叉树调整为堆

    - 将初始无序的 R[1] 到 R[n] 建成一个小根堆，可用以下语句实现：

      - ```c
        for(i = n/2; i >= 1; i--)
            HeapAdjust(R, i, n);
        ```

    - 由以上分析可知：

      - 若对一个无序序列建堆，然后输出根；重复该过程就可以由一个无序序列输出有序序列
      - 实质上，堆排序就是利用完全二叉树中父结点与孩子结点之间的内在关系来排序的

    - 堆排序算法：

      - 类C代码：

        - ```c
          void HeapSort(elem R[]) //对R[1]到R[n]进行堆排序
          {
              int i;
              for(i = n/2; i >= 1; i--)
              {
                  HeapAdjust(R, i, n); //建初始堆
                  for(i = n; i > 1; i--) //进行n-1趟排序
                  {
                      Swap(R[1], R[i]); //根与最后一个元素交换
                      HeapAdjust(R, 1, i-1); //对R[1]到R[i-1]重新建堆
                  }
              }
          }
          ```

        - 

  - 如何在输出堆顶元素后，调整剩余元素为一个新的堆？

    - 小根堆：

      - 输出堆顶元素后，以堆中最后一个元素代之

      - 然后将根结点值与左右子树的根结点值进行比较，并与其中小者交换

      - 重复上述操作，直至叶子结点，将得到新的堆，称这个从堆顶至叶子的调整过程为 筛选

        - 筛选过程的算法：

          - 类C代码：

            - ```c
              void HeapAdjust(elem R[], int s, int m)
              {
                  //已知R[s...m]中记录的关键字除R[s]外均满足堆的定义，本函数调整R[s]的关键字，使R[s...m]成为一个大根堆
                  rc = R[s];
                  for(j = 2*s; j <= m; j *= 2) //沿key较大的孩子向下筛选
                  {
                      if(j < m && R[j] < R[j+1])
                          j++; //j为key较大的记录的下标
                      if(rc >= R[j])
                          break;
                      R[s] = R[j];
                      s = j; //rc应插入在位置s上
                  }
                  R[s] = rc; //插入
              }
              ```

          - C语言实现：

            - ```c
              ```

        - 可以看出：对一个无序序列反复筛选就可以得到一个堆，即：从一个无序序列建堆的过程就是一个反复筛选的过程

- 堆排序的算法性能分析：

  - 初始堆化所需时间不超过O(n)
  - 排序阶段（不含初始堆化）：
    - 一次重新堆化所需时间不超过O(logn)
    - n-1 次循环所需时间不超过O(nlogn)
      - Tw(n) = O(n) + O(nlogn) = O(nlogn)
  - 堆排序的时间主要耗费在建初始堆和调整建新堆时进行的反复筛选上。堆排序在最坏情况下，其时间复杂度也为O(nlogn)，这是堆排序最大的优点。无论待排序列中的记录是正序还是逆序排列，都不会时堆排序处于最好或最坏状态
  - 另外，堆排序仅需一个记录大小供交换用的辅助储存空间
  - 然而堆排序是一种不稳定的排序方法，它不适用于待排序记录个数n较少的情况，但对于 n 较大的文件还是很有效的

## （五）归并排序

- 基本思想：
  - 将两个或两个以上的有序子序列 归并 为一个有序序列
- 在内部排序中，通常采用的是 2-路归并排序
  - 即：将两个位置相邻的有序子序列归并
- 如何将两个有序序列合成一个有序序列
  - 设 R[low] - R[mid] 和 R[mid+1] - R[high] 为相邻，归并称一个有序序列 R1[low] - R1[high]
  - 若 SR[ i ].key <= SR[ j ].key，则 TR[ k ] = SR[ i ]; k++; i++
    - 否则 TR[ k ] = SR[ j ]; k++; j++
- 归并排序算法分析：
  - 时间效率：O(nlogn)
  - 空间效率：O(n)
    - 因为需要一个于原始序列同样大小的辅助序列 R1。这正是此算法的缺点
  - 稳定性：稳定

## （六）基数排序

- 基本思想：分配 + 收集
  - 也叫桶排序或箱排序：设置若干个箱子，将关键字为 k 的记录放入第 k 个箱子，如何在按序号将非空的连接
- 基数排序：
  - 数字是有范围的，均由0~9这十个数字组成，则只需设置十个箱子，相继按个、十、百进行排序
- 基数排序算法分析：
  - 时间效率：O(k*(n+m)) 
    - k：关键字个数
    - m：关键字取值范围为m个值
  - 空间效率：O(n+m)
  - 稳定性：稳定

## （七）外部排序

## 各类排序方法比较

|          |              |          | 时间复杂度 |          | 空间复杂度 |        |
| -------- | ------------ | -------- | ---------- | -------- | ---------- | ------ |
| 类别     | 排序方法     | 最好情况 | 最坏情况   | 平均情况 | 辅助储存   | 稳定性 |
| 插入排序 | 直接插入排序 | O(n) | O(n^2) | O(n^2) | O(1) | 稳定 |
| 插入排序 | 希尔排序     | O(n) | O(n^2) | O(n^1.3) | O(1) | 不稳定 |
| 交换排序 | 冒泡排序               | O(n) | O(n^2) | O(n^2) | O(1) |稳定|
| 交换排序 | 快速排序     | O(nlogn) | O(n^2) | O(nlogn) | O(nlogn) | 不稳定 |
| 选择排序 | 直接选择排序 | O(n^2) | O(n^2) | O(n^2) | O(1) | 不稳定 |
| 选择排序 | 堆排序 | O(nlogn) | O(nlogn) | O(nlogn) | O(n^2) | 不稳定 |
| 归并排序 | 归并排序 | O(nlogn) | O(nlogn) | O(nlogn) | O(n) | 稳定 |
| 基数排序 | 基数排序 | O(m+n) | O(k*(m+n)) | O(k*(m+n)) | O(m+n) | 稳定 |



