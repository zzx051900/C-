- 网课视频
  - 青岛大学王卓：10，11，12，13，14，&15，&16，17，18，19，20，21，22，23，24，25，26，27，28，29，30，31，32，33，34，35，36，37，38，39，40，41，42，43，44，45，46，47，48，49，50，51（62）

# 2.线性表

## 案例：稀疏多项式的运算

- 创建一个新数组c
- 分别从头遍历比较a和b的每一项
  - 指数相同：对应系数相加，若其和不为零，则在c中增加一个新项
  - 指数不相同：则将较小项复制到c中
- 当其中一个多项式遍历完毕，将另一个剩余项复制到c中即可

## 线性表的基本操作：

1. InitList(&L)

   - 线性表的初始化
   - 操作结果：构建一个空的线性表L

2. DestroyList(&L)

   - 初始条件：线性表L已经存在
   - 操作结果：销毁线性表L（表本身消失）

3. ClearList(&L)

   - 初始条件：线性表L已经存在
   - 操作结果：将线性表L重置为空表（表仍存在）

4. ListEmpty(L)

   - 初始条件：线性表L已经存在
   - 操作结果：若线性表为空，则返回TURE；否则返回FALSE

5. ListLength(L)

   - 初始条件：线性表L已经存在
   - 操作结果：返回线性表中元素个数

6. GetElem(L,i,&e)

   - 初始条件：线性表L已经存在，1<=i<=ListLength(L)
   - 操作结果：用e返回线性表L中第i个元素的值

7. LocateElem(L,e,compare())

   - 初始条件：线性表L已经存在，compare()是数据元素判定函数
   - 操作结果：返回L中第一个与e满足compare()的数据元素的位序，若不存在，则返回0

8. PriorElem(L,cur_e,&pre_e)

   - 初始条件：线性表L已经存在
   - 操作结果：若cur_e，是L的数据元素，且不是第一个，则用pre_e返回他的前驱，否则操作失败，pre_e无意义

9. NextElem(L,cur_e,&next_e)

   - 初始条件：线性表L已经存在

   - 操作结果：若cur_e，是L的数据元素，且不是最后一个，则用next_e返回他的前驱，否则操作失败，next_e无意义

10. ListInsert(&L,i,e)

    - 初始条件：线性表L已经存在，i<=i<=ListLength(L)+1
    - 操作结果：在L的第i个位置前插入新的元素e，L的长度加一

11. ListDelete(&L,i,&e)

    - 初始条件：线性表L已经存在，i<=i<=ListLength(L)
    - 操作结果：删除L的第i个数据元素，并用e返回其值，L的长度减一

12. ListTraverse(&L,visited())

    - 初始条件：线性表L已经存在
    - 操作结果：依次对线性表L中每个元素调用visited()

## 算法中用到的预定义常量和类型

- ```c
  //函数结果状态代码
  #define TURE 1
  #define FALSE 0
  #define OK 1
  #define ERROR 0
  #define INFEASIBLE -1
  #define OVERFLOW -2
  //Status 是函数的类型，其值是函数结果状态代码
  typedef int Status;
  typedef char ElemType;
  ```

## 顺序表

### 1.顺序表中元素存储位置的计算

- 假设线性表的每个元素需占用i个存储单元，则第i+j个元素的存储位置和第i个元素的存储位置之间满足关系：
  - LOC(a(n+1))=LOC(a(n))+i

### 2.顺序表的特点

- 以物理位置相邻表示逻辑关系，任一元素均可随机存取

### 3.顺序表

1. 地址连续
2. 依次存放
3. 随机存取
4. 类型相同

### 4.顺序表的类C语言代码实现

- ```c
  #define LIST_INIT_SIZE 100//线性表存储空间的初始分配量
  typedef struct
  {
      ElemType elem[LIST_INIT_SIZE];//方案1：静态数组方式
      ElemType *elem;//方案2：动态内存分配方式
      int length;//当前长度
  }SqList;
  SqList L;//定义变量L，L是SqList这种类型的变量，L是个顺序表
  L.elem=(ElemType*)malloc(sizeof(ElemType)*MAXSIZE);//动态内存分配
  ```

- 多项式的顺序存储结构类型定义

  - ```c
    #define MAXSIZE 1000  //多项式可能达到的最大长度
    typedef struct  //多项式非零项的定义
    {
        float p;//系数
        int e;//指数
    }Polynomial;//多项式
    typedef struct
    {
        Polynomial *elem;//存储空间的首地址，以自定义数据类型建立的数组
        int length;//多项式中当前项的个数
    }SqList;//多项式的顺序存储结构类型为SqList
    ```

- 图书表的顺序存储结构类型定义

  - ```c
    #define MAXSIZE 10000  //图书表可能达到的最大长度
    typedef stcuct  //单本图书信息定义
    {
        char no[20]; //图书ISBN
        char name[50]; //图书名字
        float price; //图书价格
    }Book;
    typedef struct
    {
        Book *elem; //存储空间的基地址
        int length; //图书表中的当前图书个数
    }SqList; //图书表的顺序存储结构为SqList
    ```

- 操作算法中用到的预定常量和类型

  - ```c
    //函数结果状态代码
    #define TURE 1
    #define FALSE 0
    #define OK 1
    #define ERROR 0
    #define INFEASIBLE -1
    #define OVERFLOW -2
    //Status 是函数的类型，其值的函数结果代码
    typedef int Status
    typedef char ElemType    
    ```

### 5.顺序表基本操作的实现（类C语言代码）

  #### 算法1：线性表L的初始化（参数用引用）

```c
Status InitList_Sq(SqList &L)		//构造一个空的顺序表L
{
    L.elem=new ElemType[MAXSIZE];	//为顺序表分配空间，C++类型？？
    if(!L.elem)
        exit(OverFLOW);				//存储分配失败,异常处理
    L.length=0;						//空表长度为0
    return 0;
}
```

#### 算法2：销毁线性表L    

```c
void DestroyList(SqList &L)
  {
      if(L.elem)
          delete L.elem;  //释放空间，C++语法，具体C语言代码实现不是这样
  }
```

#### 算法3：清空线性表L

```c
  void ClearList(SqList &L)
  {
      L.length=0;  //将线性表长度置为0
  }
```

#### 算法4：求线性表长度

```c
  int GetLength(SqList L)
  {
      return (L.length);
  }
```

#### 算法5：判断线性表L是否为空

```c
  int IsEmpty(SqList L)
  {
      if(L.length==0)
          return 1;  //若为空，则返回1
      return 0;
  }
```

#### 算法6：顺序表取值（根须位置i获取相应位置数据元素的值，用e返回）

```c
 Status GetElem(SqList L,int i,ElemType &e)
  {
      if(i<1||i>L.length)
          return ERROR;  //判断i值是否合理，若不合理，返回ERROR
      e=L.elem[i-1];  //第i-1个单元存储着第i个数据
      return OK;
  }
  //随机存取，时间复杂度为O(1)
```

#### 算法7：顺序表的查找

```c
  //在线性表L中查找与指定值e相同的数据元素的位置
  //从表的一端开始，逐个进行记录的关键字和给定值的比较。找到，返回该元素的位置序号，未找到，则返回0
  int LocateElem(SqList L,ElemType e)
  {
      for(i=0;i<L.length;i++)
      {
          if(L.length[i]==e)
              return i+1;//eg:数组a[0]的位置序号是1
      }
      return 0;//未找到，返回0
  }
```

#### 算法8：顺序表的插入

```c
 /*算法思想：
  1.判断插入位置i是否合法(i<1||i>L.length+1)
  2.判断顺序表的存储空间是否已满，若已满则返回ERROR
  3.将第n至第i位的元素依次向后移动一个位置，空出第i个位置
  4.将要插入的新元素放入第i个位置
  */
  Status ListInsert_Sq(SqList &L,int i,ElemType e)
  {
      if(i<1||i>L.length+1)
          return ERROR;   //i值不合法
      if(L.length==MAXSIZE)
          return ERROR;   //当前存储空间已满
      for(j=L.length-1;j>=i-1;j++)
          L.elem[j+1]=L.elem[j];    //插入位置及之后元素后移
      L.elem[i-1]=e;  //将新元素e放入第i个位置
      L.length++;     //表长加一
      return OK;
  }
```

#### 算法9：顺序表的删除

```c
  /*算法思想：
  1.判断删除位置是否合法(1<i<n)
  2.将第i+1至n位的元素依次向前移动一个位置
  3.表长减一，返回OK
  */
  Status ListDelete_Sq(SqList &L,int i)
  {
      if(i<1||i>L.length)
          return ERROR;   //i值不合法
     for(j=i;j<L.length-1;j++)
          L.elem[j-1]=L.elem[j];   //元素前移
      L.length--; 
  }
```

## 链表

### 1.在链表中设置头结点有什么好处？

1. 便于首元结点的处理
   - 首元结点的地址保存在头结点的指针域中，所以在链表第一个位置上的操作和其他位置一致，无需进行特殊处理
2. 便于空表和非空表的统一处理
   - 无论链表是否为空，头指针都是指向头结点的非空指针，因此空表和非空表的处理也就统一了

### 2.单链表结点的定义：

- ```c
  typedef struct Lnode
  {
      ElemType data; //结点的数据域
      struct Lnode *next; //结点的指针域
  }Lnode,*LinkList; //LinkList为指向结构体Lnode的指针类型
  //定义一个结构体类型指针的两种方式
  Lnode *p;
  LinkList L;
  //一般区分使用:
  //定义链表L
  LinkList L;
  //定义结点指针p:
  Lnode *p;
  ```

### 3.单链表结构的定义和表示

- eg：存储学生学号、姓名、成绩的单链表结点类型定义

  - 方式a：不常用，因为存在多个数据域

    - ```c
      typedef struct student
      {
          char num[8];//学号
          char name[8];//姓名
          int score;//成绩
          struct student *next; //指针域
      }Lnode,*LinkList;
      
      LinkList L;
      ```
  - 方式b：常用，将多个数据的内容先定义成一个结构体

    - ```c
      typedef struct
      {
          char num[8];//学号
          char name[8];//姓名
          int score;//成绩
      }ElemType;
      
      typedef struct Lnode
      {
          ElemType data;
          struct Lnode *next;
      }Lnode,*LinkList;
      ```

### 4.单链表基本操作的类C语言实现

#### 算法1：单链表的初始化

- ```c
  /*算法步骤：
  1.生成新节点作为头结点，用头指针L指向头结点
  2.将头结点的指针域置空
  */
  Status InitList_L(LinkList &L)
  {
      L=(LinkList)malloc(sizeof(Lnode));
      L->next=NULL;
      return OK;
  }
  ```

#### 算法2：判断链表是否为空

  - ```c
    //空表：链表中无元素，但头指针和头结点仍存在
    //算法思路：判断头结点指针域是否为空
    int ListEmpty(LinkList L) //若为空返回1，否则返回0
    {
        if(L->next)
            return 0;
        else
            return 1;
    }
    ```

#### 算法3：单链表的销毁，销毁后不存在

  - ```c
    //算法思路：从头指针开始，依次释放所有结点
    Status DestroyList_L(LinkList &L)
    {
        Lnode *p;
        while(L)
        {
            p=L;
            L=L->next;
            free(p);
        }
        return OK;
    }
    ```

#### 算法4：清空单链表

  - ```c
    //依次释放所有结点，并将头结点指针域设置为空
    Status ClearList_L(LinkList &L)
    {
        Lnode *p,*q;
        p=L->next;
        while(p)
        {
       	 	q=p->next;
        	free(p);
            p=q;
        }
        L->next=NULL;
        return 0;
    }
    ```

#### 算法5：求单链表表长

  - ```c
    //算法思路：从首元结点开始，依次计数所有结点
    int ListLength_L(LinkList L)
    {
        Lnode *p;
        p=L->next;//p指向第一个结点
        i=0;
        while(p)
        {
            i++;
            p->next;
        }
        return i;
    }
    ```

#### 算法6：取第i个元素的值

  - 按位查找：

    - ```c
      Status GetElem_L(LinkList L,int i,ElemType &e)
      {
          p=L-next;  //p指向首元结点
          j=1;
          while(p&&j<i) //向后扫描直到p指向第i个元素或p为空
          {
              p=p->next;
              ++j;
          }
          if(!p||j>i)
              return ERROR; //第i个元素不存在
          e=p->data;
          return OK;
      }
      ```

  - 按值查找：根据指定数据获取该数据所在的位置(地址或序号)

    - 返回地址

      ```c
      Lnode *LocateElem_L(LinkList L,ElemType e)
      {
          p=L->next;
          while(p&&p->data!=e)
          {
              p=p->next;
          }
          return p;
      }
      ```

    - 返回序号

      ```c
      int LocateElem_L(LinkList L,ElemType e)
      {
          p=L->next;
          j=1;
          while(p&&p->data!=e)
          {
              p=p->next;
              j++;
          }//如果没找到，则p为空
          if(p)
              return j;
          return 0;//查找失败返回0
      }
      ```

#### 算法7：插入结点（在第i个结点前插入值为e的新结点）

  - ```c
    Status ListInsert_L(LinkList &L,int i,ElemType e)
    {
        p=L;
        j=0;
        while(p && j<i-1) //寻找第i-1个结点，p指向i-1结点
        {
            p=p->next;
            j++;
        }
        if(!p||j>i-1)
            return ERROR;  //i大于表长+1或小于1，插入位置非法
        s=(*Lnode)malloc(sizeof(Lnode));    //新建一个s结点（可能有问题）
        s->data=e; //生成新结点，将结点的数据域置为e
        s->next=p->next;
        p->next=s; //顺序不可颠倒
        return OK;
    }
    ```

#### 算法8：删除第i个结点（删除第i个元素）

  - ```c
    Status ListDelete_L(LinkList &L,int i,ElemType &e)
    {
        p=L; //指向头结点
        j=0; 
        while(p->next&&j<i-1) //寻找第i-1个结点，且第i个结点不能为空
        {
            p=p->next;
            j++;
        }
        if(!(p->next)||j>i-1)
            return ERROR;
        q=p->next; //临时保存被删结点的地址以备释放
        p->next=q->next;
        e=q->data; //存放删除结点的数据
        free(q);//释放删除结点的空间
        return OK;
    }
    ```

#### 算法9：头插法建立单链表

  - ```c
    void CreateList_H(LinkList &L,int n) //n 为插入的元素个数
    {
        L=(*Lnode)malloc(sizeof(Lnode)); //头结点
        L->next=NULL;
        for(i=n;i>0;i--)
        {0
            p=(*Lnode)malloc(sizeof(Lnode)); //新结点
            //输入元素，存在p->data;
            p->next=L->next;
            L->next=p;
        }
    } //时间复杂度O(n)
    ```

#### 算法10：尾插法建立单链表

  - ```c
    /*
    1.从一个空表L开始，将新结点逐个插入到链表尾部，尾指针r指向链表尾部
    2.初始时，r同L均指向头结点。每读入一个数据元素则申请一个新结点，将新结点插入到尾结点后，r指向新结点
    */
    void CreateList_R(LinkList &L,int n)
    {
        L=(*Lnode)malloc(sizeof(Lnode)); //头结点
        L->next=NULL;
        r=L; //尾指针指向头结点
        for(i=0;i<n;i++)
        {
            p=(*Lnode)malloc(sizeof(Lnode)); //新结点
            //输入元素，存在p->data;
            p->next=NULL;
            r->next=p;
            r=p; //尾指针指向新的尾结点
        }
    } //时间复杂度O(n)
    ```

### 5.循环链表：头尾相接的链表（最后一个结点的指针域指向头结点，整个链表形成一个环）

- 优点：从表中任一结点出发均可找到表中其他结点

- 注意：循环链表中没有NULL指针，故涉及遍历操作时，终止条件为是否等于头指针

- eg：带尾指针循环链表的合并（尾指针Ta和Tb）

    - 操作步骤：

        1. p存Ta的表头结点：p=Ta->next
        2. Tb表头连接到Ta表尾：Ta->next=Tb->next->next
        3. 释放Tb表头结点：free(Tb-next)
        4. Tb指向Ta的头结点：Tb->next=p

    - ```c
        LinkList Connect(LinkList Ta,LinkList Tb)
        {
            p=Ta->next;
            Ta->next=Tb->next->next;
            free(Tb-next);
            Tb->next=p;
            return Tb;
        }
        ```

### 6.双向链表：在单链表的每个结点里再增加一个指向其直接前驱的指针域prior

- 双向链表的结构定义：

    - ```c
        typedef struct DuLnode
        {
            ElemType data;
            struct DuLnode *prior,*next;
        }DuLnode,*DuLinkList;
        ```

- 双向链表的对称性：

    - p->prior->next=p=p->next->prior

- 双向链表中，插入、删除操作需要同时修改两个方向上的指针

    - 双向链表的插入操作：

        - ```c
            void ListInsert_DuL(DuLinkList &L;int i;ElemType e) //在带头结点的双向链表L的第i个位置前插入元素e
            {
                if(!(p=GetElemP_DuL(L,i))) //找到第i个元素
                    return ERROR;
                s=(*DuLnode)malloc(sizeof(DuLnode));
                s->data=e;
                s->prior=p->prior; //将新结点的前驱改为p的前驱
                p->prior->next=s; //将p的前驱的后继改为新结点
                p->prior=s; //p的前驱改为新结点s
                s->next=p; //新结点s的后继改为p
            }
            ```

    - 双向链表的删除：

        - ```c
            void ListDelete_DuL(DuLinkList &L;int i;ElemType &e) //删除第i个元素，并用e返回
            {
                if(!(p=GetElemP_DuL(L,i))) //找到第i个元素
                    return ERROR;
                e=p->data;
                p->prior->next=p->next; //p的前驱的后继改为p的后继
                p->next->prior=p->prior; //p的后继的前驱改为p的前驱
                free(p);
            }
            ```

### 7.单链表、循环链表和双向链表的时间效率比较

- |                                 |         查找首元结点         |             查找表尾结点              |            查找结点*p的前驱结点            |
    | ------------------------------- | :--------------------------: | :-----------------------------------: | :----------------------------------------: |
    | 带头结点的单链表L               |    L->next 时间复杂度O(1)    | 从L->next依次向后遍历，时间复杂度O(n) |          通过p->next无法找到前驱           |
    | 带头结点仅设头指针L的循环单链表 |    L->next 时间复杂度O(1)    | 从L->next依次向后遍历，时间复杂度O(n) |  通过p->next可以找到前驱，时间复杂度O(n)   |
    | 带头结点仅设尾指针R的循环单链表 | R->next->next 时间复杂度O(1) |           R，时间复杂度O(1)           |  通过p->next可以找到前驱，时间复杂度O(n)   |
    | 带头指针的双向循环链表L         |    L->next 时间复杂度O(1)    |       L->prior，时间复杂度O(1)        | p->prior，时间复杂度O(1)顺序表和链表的比较 |

### 8常见问题：

1. 为什么单链表初始化时用二级指针，而插入操作时用一级指针？

   - 在初始化过程中，需要修改头指针，因此要用到二级指针传递头指针的地址，这样才能修改头指针。这与普通变量类似，当需要修改普通变量的值，需传递其地址。使用二级指针，很方便就修改了传入的结点一级指针的值。 如果用一级指针，则只能通过指针修改指针所指内容，却无法修改指针的值，也就是指针所指的内存块。

   - 在使用带头结点的单链表时
     1、初始化链表头部指针需要用二级指针
     2、销毁链表需要用到二级指针
     3、插入、删除、遍历、清空结点用一级指针即可

     注意：
     如果是不带头结点的单链表，插入、删除和清空结点也需要二级指针（比如往空链表中插入一个节点时，新插入的节点就是链表的头指针，此时会改动头指针。同理，删除第一个结点和清空结点都会改动头指针）。

2. 

## 顺序表的链表的比较

- 链式存储结构：
  - 优点：
    - 节点空间可以动态申请和释放
    - 数据元素的逻辑次序靠结点的指针来指示，插入和删除时不需要移动数据元素
  - 缺点：
    - 存储密度小，每个结点的指针域需额外占用存储空间。当每个结点的数据域所占字节不多时，指针域所占存储空间的比重显得很大（存储密度=结点数据所占空间/结点所占的空间总量）
    - 链式存储结构时非随机存取结构》对任意结点的操作都要从头指针依指针链查找到该结点
- 空间：
  - 存储空间：
    - 顺序表：预先分配，会导致空闲限制或溢出
    - 链表：动态分配，不会出现存储空间闲置或溢出
  - 存储密度：
    - 顺序表：不用为表示结点间的逻辑关系而额外增加存储开销，存储密度为1
    - 链表：需要借助指针来体现元素间的逻辑关系，存储密度小于1
- 时间：
  - 存取元素：
    - 顺序表：随机存取，按位置访问元素时间复杂度为O(1)
    - 链表：顺序存取，按位置访问元素时间复杂度为O(n)
  - 插入、删除：
    - 顺序表：平均移动表中一半元素，时间复杂度为O(n)
    - 链表：不需要移动元素，确定位置后，时间复杂度为O(1)
- 使用情况：
  - 顺序表：
    1. 表长变化不大，且能事先确定变化的范围
    2. 很少进行插入或删除的操作，经常按元素位置序号访问数据元素
  - 链表：
    1. 长度变化很大
    2. 频繁进行插入或删除操作 

## 线性表的应用

### 1.线性表的合并

- 算法步骤：

  - 依次取出Lb中的每个元素，执行以下操作：
    1. 在La中查找该元素
    2. 如果找不到，则将其插入到La的最后

- ```c
  void union(List &La,List Lb)//仅表示思路
  {
      La_len=ListLength(La);//求线性表La的长度
      Lb_len=ListLength(Lb);
      for(i=1;i<Lb_len;i++)//遍历Lb中元素
      {
          GetElem(Lb,i,e);
          if(!(LocateElem(La,e)))//执行条件为，在La中找不到元素e
              ListInsert(La,++La_len,e);//插入到第表长加一个位置
      }
  }
  ```

### 2.有序表的合并（顺序表）

- 已知线性表La和Lb中的数据元素非递减有序排列，现要求将两表归并为一个新的非递减有序排列
- 算法步骤：
  1. 创建一个空表c
  2. 依次从La和Lb中摘取元素值较小的结点插入到Lc表的最后，直至其中一个表为空
  3. 继续将没有空的那个表的剩余结点插入到Lc表的最后
  
- ```c
  void MergeList_Sq(SqList LA,SqList LB,SqList &LC)
  {
      pa=LA.elem;
      pb=LA.elem;//指针pa、pb分别指向两个表的第一个元素
      LC.length=LA.length+LB.length;
      LC.elem=(*ElemType)malloc(LC.length*sizeof(Elemtype));
      pc=LC.elem;//
      pa_last=LA.elem+LA.length-1;//指向LA表最后一个元素，用来记录是否遍历到了表尾
      pb_last=LB.elem+LB.length-1;
      while(pa<=pa_last&&pb<=pb_last)//两表都不为空时
      {
          if(*pa<=*pb)
          {
              *pc=*pa;
              pc++;//指针右移
              pa++;
              //或直接写成：*pc++=*pa++;
          }
          else
          {
              *pc=*pb;
              pc++;//指针右移
              pb++;
              //或直接写成：*pc++=*pb++;
          }
          while(pa<=pa_last)//此时LB表已遍历完,将LA中剩余元素加入LC
              *pc++=*pa++;
          while(pb<=pb_last)//此时LA表已遍历完,将LB中剩余元素加入LC
              *pc++=*pb++;
      }
  }
  ```

### 3.有序表的合并（链表）

- ```c
  void MergeList_L(LinkList &La,LinkList &Lb,LinkList &Lc)
  {
      pa=La->next;//pa指针指向La的首元结点
      pb=Lb->next;
      pc=Lc=La;
      while(pa && pb)//两表都不为空时
      {
          if(pa->data<pb->data)
          {
              pc->next=pa;//将pa接在pc之后
              pc=pa;//pc移动到pa
              pa=pa->next;//pa后移
          }
          else
          {
              pc->next=pb;
              pc=pb;
              pb=pb->next;
          }
      }
      pc->next=pa?pa:pb;//pa不为空则指向pa
      free(Lb);//释放Lb的头结点
  }
  ```

## 案例分析和实现

### 案例一：一元多项式的运算

- 实现两个多项式加、减、乘运算

### 案例二：稀疏多项式的运算

#### 顺序表实现

- 算法思路：

  1. 创建一个新数组c
  2. 分别从头遍历比较a和b的每一项
     - 指数相同：对应系数相加，若其和不为零，则在c中增加一个新项
     - 指数不相同：则将较小项复制到c中
  3. 当其中一个多项式遍历完毕，将另一个剩余项复制到c中即可

- 问题分析：

  - 顺序存储结构存在问题：
    - 存储空间分配不灵活
    - 运算空间复杂度高

- 算法实现：

  - ```c
    ```

#### 链表实现

- 算法思路：

  1. 创建一个只有头结点的空链表
  2. 根据多项式的个数n，循环n次执行以下操作：
     1. 生成一个新结点s
     2. 输入多项式当前项的系数和指数赋值给新结点s的数据域
     3. 设置一个前驱指针pre，用于指向待找到的第一个大于输出项指数的结点的前驱，pre初值指向头结点
     4. 指针q初始化，指向首元结点
     5. 循链向下逐个比较链表中当前结点与输入项指数，找到第一个大于输出项的结点q
     6. 将输入项结点s插入到结点q之前

- 算法描述：

  - 多项式结点的定义：

    - ```c
      typedef struct PNode
      {
          float coef;//系数
          int expn;//指数
          struct PNode *next;//指针域
      }PNode,*polynomial;
      ```

  - 多项式创建：

    - ```c
      void Createpolyn(Polynomial &P,int n)
      {
          P=(*PNode)malloc(sizeof(PNode));//先建立一个带头结点的单链表
          P->next=NULL;
          for(i=1;i<=n;i++)
          {
              s=(*PNode)malloc(sizeof(PNode));//生成新结点
              //输入系数和指数
              pre=P;//pre用于保存q的前驱，初值为头结点
              q=P->next;//q指向首元结点
              while(q && q->expn<s->expn)
              {
                  pre=q;
                  q=q->next;
              }
              s->next=q;//将输入项s插入到q和其前驱结点pre之间
              pre->next=s;
          }
      }
      ```

  - 多项式相加：

    - 算法步骤：
      1. 指针p1和p2初始化，分别指向Pa和Pb的首元结点
      2. p3指向和多项式的当前节点，初值为Pa的头结点
      3. 当指针p1和p2均未到达相应表尾时，循环比较p1和p2所指结点对应的指数(p1->expn和p2->expn)，有三种情况
         1. 当p1->expn==p2->expn时，则将两个结点中的系数相加
            1. 若和不为零，则修改p1所对应的结点的系数值，同时删除p2所指结点
            2. 若和为零，则删除p1和p2所指结点
         2. 当p1->expn<p2->expn时，则摘取p1所指结点到“和多项式”链表中
         3. 当p1->expn>p2->expn时，则摘取p2所指结点到“和多项式”链表中
      4. 将非空多项式剩余段插入p3所指结点之后
      5. 释放Pb的头结点

### 案例三：图书信息管理

- 结构类型定义

  - ```c
    struct Book
    {
        char id[20];//ISBN
        char name[50];//书名
        int price;//定价
    }
    
    typedef struct
    {
        Book *elem;
        int length;
    }SqList;//顺序表定义
    
    typedef struct LNode
    {
        Book data;
        struct LNode *next;
    }LNode,*LinkList;//链表定义
    ```

# 3.栈和队列

## 栈和队列的定义和特点

- 栈和队列是限定插入和删除只能在表的端点进行的线性表
- 栈(stack)是一个特殊的线性表，是限定在一端进行插入和删除的线性表，后进先出(Last In First Out)，简称(LIFO)
  - 栈仅在表尾（栈顶）进行插入、删除
  - 表尾(an)称为栈顶（Top），表头(a1)称为（Base）
  - eg：栈 s=(a1,a2,......an);
  - 插入到栈顶称为入栈，从栈顶删除叫出栈

- 队列(queue)，是一种先进先出(First In First Out)的线性表(FIFO)，在表一端（表尾）插入，在另一端（表头）删除

### 栈的应用

- “先进后出，后进先出”

  - 数值转换

  - 表达式求值

  - 括号匹配的检验

  - 八皇后问题

  - 行编辑程序

  - 函数调用

  - 迷宫求解

  - 递归调用的实现

### 队列的应用

- “先进先出，后进后出”，类似排队问题
  - 脱机打印：按申请的先后顺序依次输出
  - 多用户系统中，多个用户排队，分别循环使用CPU和主存
  - 按用户的优先级排成队，每个优先级一个队列
  - 实时控制系统，信号按接收的先后顺序依次处理
  - 网络电文传输，按到达的时间先后顺序依次处理

## 案例引入

### 案例一：进制转换

### 案例二：括号匹配的检验

### 案例三：表达式求值

### 案例四：舞伴问题

## 栈的表示和实现

### 栈的抽象数据类型定义

- ```c
  ADT Stack{
      数据对象：
          D={ai|ai∈ElemSet，i=1,2,3,......,n,n>=0};
      数据关系
          R1={<ai-1,ai>|ai-1,ai∈D,i=2,...,n};
      基本操作：初始化、进栈、出栈、取栈顶元素等;
  }ADT Stack
  ```

### 栈的基本操作

1. InitStack(&S)
   - 栈的初始化
   - 操作结果：构造一个空栈S
2. DestroyStack(&S)
   - 栈的销毁
   - 初始条件：栈S已经存在
   - 操作结果：栈S被销毁
3. StackEmpty(S)
   - 判定栈S是否为空栈
   - 初始条件：栈S已经存在
   - 操作结果：若栈S为空栈，则返回TURE；否则返回FALSE
4. StackLength(S)
   - 求栈的长度
   - 初始条件：栈S已经存在
   - 操作结果：返回S的元素个数，即栈的长度
5. GetTop(S,&e)
   - 取栈顶元素
   - 初始条件：栈S已经存在，且非空
   - 操作结果：用e返回S的栈顶元素
6. ClearStack(&S)
   - 清空栈
   - 初始条件：栈S已经存在
   - 操作结果：将栈S清空
7. Push(&S,e)
   - 入栈
   - 初始条件：栈S已经存在
   - 操作结果：插入元素e为新的栈顶元素
8. Pop(&S,&e)
   - 出栈
   - 初始条件：栈S已经存在
   - 操作结果：删除栈顶元素an，并用e返回其值

### 顺序栈的表示和实现

- 存储方式：同一般线性表的顺序存储结构完全相同

  - 利用一组地址连续的存储单元依次存放自栈底到栈顶的元素，栈底一般在低地址处
  - 附设top指针，指示栈顶元素在顺序栈中的位置
  - 另设base指针，指示栈底元素在顺序栈中的位置
  - 但是为了方便操作，通常top指示真正的栈顶元素之上的下标地址
  - 另外，用stacksize表示栈可使用的最大容量

- 顺序栈的表示（类C）

  - ```c
    #define MAXSIZE 100
    typedef struct
    {
        SElemType *base;//栈底指针
        SElemType *top;//栈顶指针
        int stacksize;//栈可用最大容量
    }SqStack;
    ```

#### 顺序栈的基本操作实现

##### 算法1：顺序栈的初始化

- ```c
  Status InitStack(SqStack &S)
  {
      S.base=(SElemType*)malloc(MAXSIZE*sizeof(SElemType));
      if(!S.base)
          exit(OVERFLOW);//存储分配失败
      S.top=S.base;//栈顶指针等于栈底指针
      S.stacksize=MAXSIZE;
      return OK;
  }
  ```

##### 算法2：顺序栈判断是否为空

- ```c
  Status StackEmpty(SqStack S) //若栈为空，返回TURE;若不为空，返回FALSE
  {
      if(S.top == S.base)
          return TURE;
      return FALSE;
  }
  ```

##### 算法3：求顺序栈长度

- ```c
  int StackLength(SqStack S)
  {
      return S.top-S.base;//涉及指针减指针这一特殊情况
  }
  ```

##### 算法4：清空栈

- ```c
  Status ClearStack(SqStack S)
  {
      if(S.base)
          S.top=S.base;//直接将栈顶指针指向栈底指针
      return OK;
  }
  ```

##### 算法5：销毁栈

- ```c
  Status DestroyStack(SqStack &S)
  {
      if(S.base)
      {
          free(S.base);
          S.stacksize=0
              ;
          S.base=S.top=NULL;
      }
      return OK;
  }
  ```

- 