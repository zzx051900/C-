- 网课（黑马程序员）（共314节）：1，2，3，4，5，6，7，8，9，10，11，12，13，14，15，16，17，18，19，20，21，22，23，24，25，26，27，28，29，30，31，32，33，34，35，36，37，38，39，40，41，42，43，44，45，46，47，48，49，50，51，52，53，54，55，56，57，58，59，60，61
- 课程安排：
  - 第一阶段：C++基础入门，对C++有初步了解（案例：通讯录管理系统）
  - 第二阶段：C++核心编程，介绍C++面向对象编程，为大型项目做铺垫（职工管理系统）
  - 第三阶段：介绍C++泛型编程思想，以及STL的基本使用（演讲比赛系统）
  - 综合大案例：机房预约系统
- 在typora中打开超链接的方式：Ctrl+鼠标左键点击

# 一.C++基础入门

## （一）.C++初识

### 1.第一个C++程序：

- 输出Hello World

- ```c++
  #include<iostream>
  using namespace std;
  
  int main()
  {
  	cout << "hello world" << endl;
  	system("pause");
  	return 0;
  }
  ```

### 2.注释

- 单行注释（通常放在一行代码上方，或一条语句末尾）

  - ```c++
    //单行注释
    ```

- 多行注释（通常放在一段代码上方）

  - ```c++
    /*
    多行注释
    */
    ```

### 3.变量

- 变量的作用：给一段指定的空间起名，方便操作这段内存
- 语法：`数据类型 变量名 = 初始值;`

### 4.常量

- 作用：用于记录程序中不可更改的数据

- C++定义常量的两种方法

  1. `#define 常量名 常量值`
     
  2. `const 数据类型 常量名 = 常量值`

### 5.关键字

- 再给变量或常量起名时，不得使用C++关键字

### 6.标识符命名规则

- 标识符不能是关键字
- 标识符只能由字母、数字、下划线组成
- 第一个字符必须为字母或下划线，不能是数字
- 标识符区分大小写
- 建议：给变量起名时，最好能见名知意

## （二）.数据类型

### 1.整形

| 数据类型            | 占用空间                                               |
| ------------------- | ------------------------------------------------------ |
| short(短整型)       | 2字节                                                  |
| int(整形)           | 4字节                                                  |
| long(长整型)        | Windows系统为4字节,Linux(32位)为4字节、（64位）为8字节 |
| long long(长长整形) | 8字节                                                  |

### 2.sizeof关键字

- 作用：统计数据类型所占内存大小
- 语法：`sizeof(数据类型/变量)`

### 3.实型（浮点型）

- 作用：表示小数
- 浮点型变量分两种：
  1. 单精度浮点型float（通常在float类型后加一个f），占用4个字节空间，7位有效数字
     - 科学计数法：
       - `float f=3e2;//3*10^2`
       - `float f=3e-2;//3*0.1^2`
  2. 双精度浮点型double，占用8个字节，15~16位有效数字
- 默认情况下，输出一个小数，会显示出六位有效数字

### 4.字符型

- 作用：显示单个字符
- 语法：`char ch = 'a';`
- C和C++中字符型变量只占用一个字节
- 字符型变量并不是把字符本身放到内存中存储，而是把对应的ASCll编码放到存储单元中
- 常见错误：
  - `char ch = "b";//创建字符型变量时，要用单引号`
  - `char ch = 'abc';//创建字符型变量时，单引号内只能有一个字符`
- 查看字符型变量对应的ASCll编码
  - `cout << (int)ch << endl;`
  - a - 97
  - A - 65
- ASCll编码
  - 非打印字符：**0~31**分配给了控制字符，用于控制打印机等外围设备
  - 打印字符：**32~126**分配给了能在键盘上找到的字符，当查看或打印文档时会出现

### 5.转移字符

- 作用：用于表示一些不能显示出来的字符
- 常用：
  - \n：换行
  - \\\：输出一个反斜杠\
  - \t：水平制表符（跳到下一个tab位置）

### 6.字符串型

- 作用：表示一串字符
- 两种风格：
  1. C语言风格字符串：`char 变量名[] = "字符串值"`
  2. C++风格字符串：`string 变量名 = "字符串值"`
     - 需要包含头文件`#include<string>`

### 7.布尔类型bool

- 作用：代表真或假的值
- bool类型只有两个值：
  - true---真（1）
  - false---假（0）
- bool类型只占1个字节大小
- 创建bool数据类型
  - `bool flag = true`
- 布尔类型，非0都是真

### 8.数据的输入

- 作用：用于从键盘获取数据

- 关键字：`cin`

- 语法：`cin >> 变量`

- 不同数据类型的输入

  1. 整形

     - ```c++
       int a = 0;
       cout << "请给整型变量a赋值" << endl;
       cin >> a;
       cout << "整型变量a = " << a << endl;
       ```

  2. 浮点型

     - ```c++
       float f = 3.14f;
       cout << "请给浮点型变量f赋值" << endl;
       cin >> f;
       cout << "浮点型变量f = " << f << endl;
       ```

  3. 字符型

     - ```c++
       char ch = 'a';
       cout << "请给字符型变量ch赋值" << endl;
       cin >> ch;
       cout << "字符型变量ch = " << ch << endl;
       ```

  4. 字符串型

     - ```c++
       string str = "abc";
       cout << "请给字符串型str赋值" << endl;
       cin >> str;
       cout << "字符串型str = " << str << endl;
       ```

  5. 布尔数据类型

     - ```c++
       bool flag = false;
       cout << "请给布尔类型flag赋值" << endl;
       cin >> flag;
       cout << "布尔类型flag = " << flag << endl;
       ```

## （三）.运算符

### 1.算术运算符

- +
- -
- *
- /
  - 除数不能为0
  - 两个整数相除仍然是整数
- %
  - 除数不能为0，也不能取模
  - 两个小数不能作取值运算
  - 只有整型变量可以作取模运算
- ++a
- a++
- --a
- a--

### 2.赋值运算符

- +=
- -=
- *=
- /=
- %=

### 3.比较运算符

- ==

- !=

- <

- >

- <=

- `>=`

### 4.逻辑运算符

- !		非
- &&    与
- ||       或

## （四）.程序流程结构

### 1.顺序结构

#### （1）if语句

- 作用：执行满足条件的语句

- if语句的三种格式：

  - 单行格式

    - ```c++
      if(条件)
      {
          条件满足的语句
      }
      ```

  - 多行格式

    - ```c++
      if(条件)
      {
          条件满足的语句
      }
      else
      {
          条件不满足的语句
      }
      ```

  - 多条件

    - ```c++
      if(条件1)
      {
          条件1满足后执行的语句
      }
      else if(条件2)
      {
          条件2满足后执行的语句
      }
      ...
      else
      {
          条件都不满足执行的语句
      }
      ```

- 嵌套if语句

#### （2）三目运算符

- 作用：通过三目运算符实现简单判断

- 语法：`表达式1 ？ 表达式2 ：表达式3`

- 解释：

  - 如果表达式1为真，执行表达式2，返回表达式2的结果
  - 如果表达式1为假，执行表达式3，返回表达式3的结果

- 在C++中三目运算符返回的是变量，可以继续赋值

  - ```c++
    int a = 10;
    int b = 20;
    int c = 0;
    (a < b ? a : b) = 100;
    cout << "a = " << a << endl;
    cout << "b = " << b << endl;
    ```

#### （3）switch语句

- 作用：执行多条件分支语句

- 语法：

  - ```c++
    switch(表达式)
    {
        case 结果1:
            执行语句;break;
        case 结果2:
            执行语句;break;
        ...
        default: 
            执行语句;break;
    }
    ```

- switch语句优缺点：

  - 缺点：判断是只能是整型或字符型，不可以是一个区间；
  - 优点：结构清晰，执行效率高

- 注意：case中如果没有break，程序会一直向下执行

### 2.循环结构

#### （1）while循环语句

- 语法：

  - ```c++
    while(循环条件)
    {
        循环语句
    }
    ```

- 注意：必须提供跳出循环的出口

- while循环练习案例：猜数字

  - 文件：[02.循环练习案例：猜数字.cpp](https://github.com/zzx051900/C-/blob/a6acf6b607c39e605b74af9503e11088bb27613e/C%2B%2B%E7%A8%8B%E5%BA%8F%E7%BB%83%E4%B9%A0%E4%BB%A3%E7%A0%81/2.%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84%E6%A1%88%E4%BE%8B-%E7%8C%9C%E6%95%B0%E5%AD%97.cpp)

#### （2）do...while循环语句

- 语法：

  - ```c++
    do
    {
        循环语句
    }while(循环条件);
    ```

- 注意：与while的区别在于do...while会先执行一次循环语句，再判断条件

- 文件：[3.循环结构案例-水仙花数.cpp](https://github.com/zzx051900/C-/blob/a6acf6b607c39e605b74af9503e11088bb27613e/C%2B%2B%E7%A8%8B%E5%BA%8F%E7%BB%83%E4%B9%A0%E4%BB%A3%E7%A0%81/3.%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84%E6%A1%88%E4%BE%8B-%E6%B0%B4%E4%BB%99%E8%8A%B1%E6%95%B0.cpp)

#### （3）for循环

- 语法：

  - ```c++
    for(起始表达式;条件表达式;末尾循环体)
    {
        循环语句
    }
    ```
  
- 文件：[4.循环结构案例-敲桌子.cpp](https://github.com/zzx051900/C-/blob/a6acf6b607c39e605b74af9503e11088bb27613e/C%2B%2B%E7%A8%8B%E5%BA%8F%E7%BB%83%E4%B9%A0%E4%BB%A3%E7%A0%81/4.%E5%BE%AA%E7%8E%AF%E6%A1%88%E4%BE%8B-%E6%95%B2%E6%A1%8C%E5%AD%90.cpp)



#### （4）嵌套循环

- 再循环里再嵌套一层循环

### 3.跳转语句

#### （1）break语句

- 作用：用于跳出选择循环或循环结构
- break使用的时机；
  - 出现在switch条件语句，终止case并跳出switch
  - 出现在循环语句，跳出当前循环
  - 出现在嵌套循环，跳出最内层的循环

#### （2）continue语句

- 在循环语句中，跳过本次循环中余下尚未执行的语句，继续执行下一次循环

#### （3）goto语句

- 作用：无条件跳转语句
- 语法：
  - `goto 标记;`    
  - `标记：`

## （五）.数组

### 1.一维数组

#### （1）一维数组的定义方式

- 三种方式：

  1. `数据类型 数组名[数组长度];`

     - 全局数组，未初始化时，默认值都是 0

     - 局部数组，未初始化时，默认值为随机的不确定的值（-858993460）

  2. `数据类型 数组名[数组长度] = {值1,值2,...};`

     - 如果在数组初始化数据时，没有全部填写完，会用0来填补数据

  3. `数据类型 数组名[] = {值1,值2,...};`

     - 这种定义方式必须有初始长度

#### （2）一维数组的数组名

- 用途：
  1. 统计整个数组在内存中的长度
     - `sizeof(arr);//整个数组占用空间`
     - `sizeof(arr[0]);//每个元素所占内存空间`
     - `sizeof(arr)/sizeof(arr[0]);//数组中元素个数`
  2. 获取数组在内存中的首地址
     - `cout << arr <<endl;`
- 注意：数组名是常量，不可以赋值

#### （3）一维数组案例

1. 文件：[5.一维数组案例-寻找最大值.cpp]()
2. 文件：[6.一维数组案例-数组元素逆置.cpp]()

#### （4）冒泡排序（升序）

- 算法思想：
  1. 比较相邻的元素，如果第一个比第二个大，就交换它们两个
  2. 对每一对相邻元素做相同工作，执行完毕后，找到第一个最大值
  3. 重复以上步骤，由于每次执行一轮会将目前最大值放在最后，所以每次执行次数减一，直到不需要比较
- 文件：[7.冒泡排序.cpp]()

### 2.二维数组

#### （1）二维数组定义方式

- 四种方式：
  1. `数据类型 数组名[行数][列数];`
  2. `数据类型 数组名[行数][列数] = {{数据1,数据2},{数据3,数据4}};`
  3. `数据类型 数组名[行数][列数] = {数据1,数据2,数据3,数据4};`
  4. `数据类型 数组名[][列数] = {数据1,数据2,数据3,数据4};`

#### （2）二维数组的数组名

- 作用：
  - 查看二维数组所占内存空间
    - `sizeof(arr);//二维数组占用空间`
    - `sizeof(arr[0]);//第一行所占内存空间`
    - `sizeof(arr)/sizeof(arr[0]);//二维数组行数`
    - `sizeof(arr[0])/sizeof(arr[0][0]);//二维数组列数`
    - `sizeof(arr)/sizeof(arr[0][0]);//数组中元素个数`
  - 查看二维数组首地址

## （六）.函数

### 1.函数的作用

- 将一段经常使用的代码封装起来，减少重复代码；一个较大的程序，一般分为若干个程序块，每个模块实现特定的功能

### 2.函数的定义

- 五个步骤：

  1. 返回值类型
  2. 函数名
  3. 参数列表
  4. 函数体语句
  5. return表达式

- 语法：

  - ```c++
    返回时类型 函数名(参数列表)
    {
        函数体语句;
        return表达式
    }
    ```

### 3.函数的调用

- 功能：使用定义好的函数
- 语法：`函数名(参数)`

### 4.值传递

- 值传递，就是函数调用时，将实参传递给形参
- 值传递时，如果形参发生改变，并不会影响实参

### 5.函数的常见样式

- 四种：
  - 无参无返
  - 有参无返
  - 无参有返
  - 有参有返

### 6.函数声明

- 作用：告诉编译器函数名称及如何调用函数，函数的实际主体可以单独定义
- 函数的声明可以多次，但是函数的定义只有一次

### 7.函数的分文件编写

- 作用：让代码结构更加清晰
- 四个步骤：
  1. 创建后缀名为.h的头文件
  2. 创建后缀名为.cpp的源文件
  3. 在头文件中写函数的声明
  4. 在源文件中写函数的定义

## （七）.指针

### 1.指针的作用

- 作用：通过指针间接访问内存
- 内存编号从0开始记录，一般用十六进制表示
- 可以用指针变量保存地址

### 2.指针变量的定义和使用

- `指针定义的语法：数据类型 *指针变量名`

- ```c++
  int a = 10;
  int *p = &a;//指针p记录变量a的地址
  ```

- 使用指针：通过解引用的方式找到指针指向的内存；指针前加 * 表示解引用，找到指针指向的内存中的数据

- `*p = 100;`

### 3.指针所占内存空间

- 在32位操作系统下，占用4个字节
- 在64位操作系统下，占用8个字节

### 4.空指针和野指针

- 空指针：指针变量指向内存中编号为0的空间
  - 用途：初始化指针变量
  - 注意空指针指向的内存不可以访问（内存编号0~255为系统占用内存，不允许用户访问）
- 野指针：指针变量指向非法的内存空间
- 总结：空指针和野指针都不是我们要访问的空间，因此不要访问

### 5.const修饰指针

- 三种情况：

  1. const修饰指针 （常量指针）

     - ```c++
       const放在指针变量的*的左边时，修饰的是*p,也就是说，不能通过p改变*p的值    
           eg：const int *p=&num;        
       		*p=20;//不可以        
       		p=&n;//可以
       ```

     - 特点：指针的指向可以修改，但是指针指向的值不可以修改

  2. const修饰常量 （指针常量）

     - ```c++
       const放在指针变量*的右边时，修饰的是p本身，即p的地址无法改变    
           eg：int * const p=&num;       
       		*p=20;//可以       
       		p=&20;//不可以
       ```

     - 特点：指针的指向不可以修改，但是指针指向的值可以修改

  3. const既修饰指针，又修饰常量

     - ```c++
       const int * const p=&num;//此时内容和地址都不能更改
       ```

### 6.指针和数组

- 利用指针访问数组元素

- ```c++
  int arr[] = {1,2,3,4,5,6,7,8,9,10};
  int *p = arr;
  cout << *p << endl;//输出数组第一个元素1
  p++;//指针向后偏移4个字节
  cout << *p << endl;//输出数组第二个元素2
  //遍历输出
  *p = arr;
  int sz = sizeof(arr)/sizeof(arr[0]);
  while(sz)
  {
      cout << *p <<endl;
      p++;
      sz--;
  }
  ```

### 7.指针和函数

- 作用：利用指针作函数参数，可以修改实参的值

- ```c++
  void swap(int* p1, int* p2)
      //这里的int* p1是表明p1是一个指针，也可写成int *p1，但这里的*p1不是解引用的意思，仅仅还是表明p1是一个指针
  {
  	int temp = 0;
  	temp = *p1;
  	*p1 = *p2;
  	*p2 = temp;
  }
  int main()
  {
  	int a = 10, b = 20;
  	cout << "a=" << a << endl;
  	cout << "b=" << b << endl;
  	swap(&a, &b);
  	cout << "a=" << a << endl;
  	cout << "b=" << b << endl;
  	system("pause");
  	return 0;
  }
  ```

### 8.指针、数组、函数

- 案例描述：封装一个函数，利用冒泡排序，实现对整型数组的排序
- 文件：8.指针配合数组和函数案例-冒泡排序.cpp

## （八）.结构体

### 1.结构体基本概念

- 结构体属于用户自定义数据类型，允许用户储存不同的数据类型

### 2.结构体定义和使用

- 语法：

  - ```c++
    struct 结构体名
    {
        结构体成员列表
    };
    ```

- 通过结构体创建变量的三种方式：

  1. `struct 结构体名 变量名;`（常用）
  2. `struct 结构体名 变量名 = {成员1值,成员2值,...};`（常用）
  3. `定义结构体时顺便创造变量`（少用）

- ```c++
  #include<iostream>
  #include<string>
  using namespace std;
  struct Student
  {
  	string name;
  	int age;
  	int score;
  }s3;
  int main()
  {
  	//第一种创建变量方式
  	struct Student s1;
  	s1.name = "aaa";
  	s1.age = 18;
  	s1.score = 100;
  	cout << "姓名：" << s1.name << " 年龄：" << s1.age << " 分数：" << s1.score << endl;
  	//第二种创建变量方式
  	struct Student s2 = { "bbb", 19, 90 };
  	cout << "姓名：" << s2.name << " 年龄：" << s2.age << " 分数：" << s2.score << endl;
  	//第三种方式，定义结构体时顺便创造变量
  	s3.name = "ccc";
  	s3.age = 20;
  	s3.score = 95;
  	cout << "姓名：" << s3.name << " 年龄：" << s3.age << " 分数：" << s3.score << endl;
  	system("pause");
  	return 0;
  }
  
  ```

- 注意：

  - 创建结构体变量的时候，关键字struct可以省略
  - 结构体变量用操作符"."访问成员

### 3.结构体数组

- 将自定义的结构体放入数组中方便维护

- 语法：

  - ```c++
    struct 结构体名 数组名[元素个数] = {{},{},...,{}};
    ```

- ```c++
  //1.定义结构体
  struct Student
  {
  	string name;
  	int age;
  	int score;
  };
  //2.创建结构体数组,并顺便给结构体数组中的元素赋值
  struct Student stuArr[] =
  {
      {"aaa",18,90},
      {"bbb",19,95},
      {"ccc",20,100}
  }
  //3.也可后续再给元素赋值
  stuArr[2].name = "ddd";
  stuArr[2].age = 21;
  stuArr[2].score = 85;
  //4.遍历结构体数组
  for(int i = 0;i < 3;i++)
  {
      cout << "姓名:" << stuArr[i].name
           << " 年龄:" << stuArr[i].age
           << " 分数:" << stuArr[i].score <<endl;
  }
  ```

### 4.结构体指针

- 作用：通过指针访问结构体中的成员

- 使用操作符`->`可以通过结构体指针访问结构体属性

- ```c++
  //1.定义结构体
  struct Student
  {
  	string name;
  	int age;
  	int score;
  };
  //2.创建结构体变量
  struct Student s = {"aaa",18,90};
  //3.通过指针指向结构体变量
  struct Student *p = &s;
  //4.通过指针访问结构体变量中的数据
  cout << "姓名:" << p->name
  	<< " 年龄:" << p->age
  	<< " 分数:" << p->score << endl;
  ```

### 5.结构体嵌套结构体

- 作用：结构体中的成员可以是另一个结构体

- ```c++
  struct Student
  {
  	string name;
  	int age;
  	int score;
  };
  struct Teacher
  {
      int id;
      string name;
      int age;
      struct Student stu;
  }
  //创建老师
  struct Teacher t;
  t.stu.name = "aaa";
  ```

### 6.结构体作函数参数

- 作用：将结构体作为参数向函数中传递

- 两种传递方式：

  - 值传递
  - 地址传递

- ```c++
  #include<iostream>
  #include<string>
  using namespace std;
  
  struct Student
  {
  	string name;
  	int age;
  	int score;
  };
  
  //输出结构体数组元素
  //值传递
  void printStu1(struct Student s)
  {
  	cout << "姓名:" << s.name
  		<< " 年龄:" << s.age
  		<< " 分数:" << s.score << endl;
  }
  
  //地址传递
  void printStu2(struct Student* p)
  {
  	cout << "姓名:" << p->name
  		<< " 年龄:" << p->age
  		<< " 分数:" << p->score << endl;
  }
  
  int main()
  {
  	struct Student s1;
  	s1.name = "aaa";
  	s1.age = 18;
  	s1.score = 100;
  
  	//值传递
  	printStu1(s1);
  
  	//地址传递
  	printStu2(&s1);
  	struct Student *p = &s1;
  	printStu2(p);
  	
  	system("pause");
  	return 0;
  }
  
  ```

- 总结：如果不想修改主函数中的数据，用值传递；反之用地址传递

### 7.结构体中const使用场景

- 作用：用const来防止误操作

- 将函数中的形参改为指针，可以减少内存空间，不会复制新的副本

  - 如果函数不需要修改结构体元素的值，在形参指针前加入const之后，一旦有修改的操作，就会报错，可以防止误操作

- ```c++
  //地址传递
  void printStu2(const struct Student* p)
  {
  	stu->age = 50;//会报错，操作失败
      cout << "姓名:" << p->name
  		<< " 年龄:" << p->age
  		<< " 分数:" << p->score << endl;
  }
  ```

### 8.结构体案例

- 案例1：
  - 案例描述：学校正在做毕设项目，每名老师带领5个学生，总共有3名老师，需求如下：
    - 设计学生和老师的结构体，其中在老师的结构体中有老师的姓名和一个存放5名学生的数组作为成员
    - 学生的成员有姓名、考试分数
    - 创建数组存放3名老师，通过函数给每个老师及所带学生赋值
    - 最终打印出老师数据以及老师所带学生的数据
  - 文件：
    - 9.1结构体案例1（视频讲解版）.cpp
    - 9.2结构体案例1（改进版）.cpp
- 案例2：
  - 案例描述：
    - 设计一个英雄的结构体，包括成员姓名，年龄，性别
    - 创建结构体数组，存放5名英雄
    - 通过冒泡排序，将数组中的英雄按照年龄进行升序排序，最终打印排序后的结果
  - 文件：10.结构体案例2.cpp

